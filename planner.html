<html>
<body>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script>

<style>
  <!--  SEE http://tscppm/Projects/Site%20Pages/Construction%20Planner.aspx  -->
  <!--  SEE also work-in-progress scripts start with words "timeline-snapshot"  -->
  <!--  SEE also http://tscppm/Projects/Site%20Pages/Construction%20Planner%20Mk%20III.aspx  -->



.chart {
margin: 0 auto;
width: 960px;
min-height: 8px;
/* height: 20px; */
/*   height: 100%; */
/* height: 8px; */
box-shadow: 0 0 3px 1px #eee;
/* overflow: hidden;*/
}

svg {
vertical-align: top;
width: 100%;
/*height: 100%; */
overflow: visible;
/* position: absolute; */
}

g {
vertical-align: top;
width: 100%;
height: 100%;
}

g.tick {
  vertical-align: inherit;
}

.group {
/*  background-color: rgba(255,0,0,0.6); */
/* position: absolute; */
}


.tooltip {
/* position: absolute; */
position: sticky;
bottom: -50;
left: 0%;
height: 120px;
/*  z-index: 1000; */
}
.axis {
/* height: 100%; */
height: 20px;
/* new stuff - SORTA WORKS BUT THE BODY DOESN'T RESIZE NOW  */
 position: sticky;
bottom: 0%;
left: 10%;
background: white;

}

.vertLabelContainer {
  position: absolute;
  /*  float: left; */
  top: 0%;
   left: 5%;
  background: none;
  /* width: 100px; */
  height: 100%;

}

.vertlabel {
  position: absolute;
  width: auto;
}

.yaxis {
/* height: 20px; */
/* new stuff - SORTA WORKS BUT THE BODY DOESN'T RESIZE NOW  */
position: absolute;
/*  float: left; */
 top: 0px;
 left: 5px;
background: none;
width: 100px;
height: 100%;

}

.axisYear { /* not used at present */
height: 20px;

 position: sticky;
bottom: 0%;
left: 0%;
color: white;

}

.axisWeek {
position: sticky;
bottom: 0%;
left: 0%;
background: white;

}


.axisWeekFloating, .axisWeekFloating3 {
position: sticky;
top: 0%;
left: 0%;
height: 20px;


}


.axisWeekFloating2 {
position: sticky;
bottom: 50%;
left: 0%;
height: 20px;
/* z-index: -9000; */
/* background: white; */

}

.axisWeekFloating g {
  color: lightgray;
    opacity: 0.3;
}

 .axisWeekFloating3 g {
  color: lightgray;
    opacity: 0.1;
}

 .axisWeekFloating2 g {
  color: lightgray;
    opacity: 0.1;
}



.axisWeekFloating text, .axisWeekFloating2 text {
  font-size: 20px;
  font-color: lightgray;
  z-order: -20000;
}

.axisWeekFloating path.domain, .axisWeekFloating2 path.domain {
  stroke-width: 0;
}

.axisWeekTopGrid {

/*   position: fixed; */

  /* position: absolute;
left: 0;
top 0; */
pointer-events: none;
path, line {
  shape-rendering: crispEdges;
  stroke: #eee;
  stroke-width: 1;

}

}


.axisWeekTopGrid >  .tick {
/*  stroke: silver; */
opacity: 0.3;
pointer-events: none;
line {
/*  opacity: 0.3; */
shape-rendering: crispEdges;
stroke: #eee !important;
}
}

.bars {
/*  min-height: 30px; */
cursor: grab;
cursor: -webkit-grab;
}
.zoom {
cursor: move;

/* pointer-events: none; */
position: absolute;
top: 0;
left: 0;
fill: none;
pointer-events: all;
}

/*
.zoom rect {
  pointer-events: none;
}
*/
/* div#slider3 {
display: inline-block;
} */

.Remove {

}

.boxPrompt {
  color: blue;
}


.gangList {
  color: silver;
  font-style: italic;
}
.zoom {
/*  z-index:-9999; */
}

.nozoom {
/*  z-index:-9999; */
}


.active {
  stroke: #000;
  stroke-width: 2px;
}

.rect {
  pointer-events: all;
  stroke: none;
  stroke-width: 40px;
}

.labelText, .barsText, .dateText, .finDateText {
  cursor: default;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.dateText {
  fill: red;
}

.darker {
  opacity: 1;
  fill: gray;
}

.changed {
  stroke: red;
}

.completed {
  stroke: green;
}


.circHandle {
  color: red;
}

table.projectInfo tr th {
  text-align: right;
  padding-right: 10px;
}

 circle:hover {
        cursor: e-resize;
      }

      circle.circInfo:hover {
             cursor: help;
           }

           .circComplete:hover {
                  cursor: url('http://tscppm/SiteAssets/scripts/prettyGantt/greencheck36x36.png') 16 16, auto;
                }

                .circRemove:hover {
                       cursor: url('http://tscppm/SiteAssets/scripts/prettyGantt/redCrossSm.png') 16 16, auto;
                     }


.completedText{
  font-size:9px;
  font-color: blue;
  fill: purple;
/*  rx: -10;
  ry: -10;  */
}

.removeText{
  font-size:9px;
  font-color: red;
  fill: red;
/*  rx: -10;
  ry: -10;  */
}

rect.barGroup:hover {
  border: black;
  border-width: 1px;
}

.thickBorder {
  stroke: "black";
  stroke-width: "2px";

}


.AssignedGroup {
/*  position: sticky; */
cursor: ns-resize;
}


#circleKeyGreenSVG {
  r: 5;
  fill: lime;
  opacity: 0.5;
  display: inline;
  height: 20;
}

#circleKeyGreen {
     width: 10px;
     height: 10px;
     -webkit-border-radius: 5px;
     -moz-border-radius: 5px;
     border-radius: 5px;
     background: lime;
     opacity: 0.5;
     display: inline-block;
   }

   #circleKeyOrange {
        width: 10px;
        height: 10px;
        -webkit-border-radius: 5px;
        -moz-border-radius: 5px;
        border-radius: 5px;
        background: DarkOrange;
        opacity: 0.5;
       display: inline-block;
      }

      #circleKeyAqua {
           width: 10px;
           height: 10px;
           -webkit-border-radius: 5px;
           -moz-border-radius: 5px;
           border-radius: 5px;
           background: aqua;
           opacity: 0.5;
          display: inline-block;
         }

         #circleKeySilver {
              width: 10px;
              height: 10px;
              -webkit-border-radius: 5px;
              -moz-border-radius: 5px;
              border-radius: 5px;
              background: Silver;
              opacity: 0.5;
             display: inline-block;

            }

.key{
  display: inline-block;
}

.hidden {
  display: none;
}

.addDef {
}
.GlossaryLink, .addDef {
cursor: help;
}



.finDateText {
  fill: gray;
}



/* colors for text display */

.green {
  color: green;
}

.darkorange {
  color: orange;
}

.blue {
  color: blue;
}

.magenta {
  color: magenta;
}

.red {
  color: red;
}

.chartAxisSpacer {
  display:none;
}

#collisionBtn {
  display: none;
}


@media print {

  .chartAxisSpacer {
    display: block;
    height: 30px;
  }

  .darker {

  }

#s4-titlerow, #suiteBar, #UnlockZoomBtn, #bw-help-tab, #updateChangedItemsBtn, #collisionBtn, .key, #clearOldBtn, #getDataBtn, #info, .removeText, .completedText, #DeltaTopNavigation {
  display: none !important;
}


.labelText {
  fill: gray;
}

  /*.axisWeekFloating {
    position: fixed;
    top: 0%;
    left: 0%; */
  /*  display: none; */
/*  }  */

  .axisWeekFloating2 {
    position: fixed;
    top: 3%;
    left: 0%;
  /*  display: none; */
  }

  .axisWeekFloating2 g {
  opacity: 0.6;
  /*  display: none; */
  }
  circle {
    display: none;
  }


  .axis {
    position: fixed;
    bottom: 0%;
    left: 0%;
  }

  .axisWeek {
  /*   display: none; */
    position: fixed;
    height:20px;
    bottom: 0px;
    left: 0%;
  /*  fill: 'none'; */
  /*  z-order: -10000; */
  }

  #chartContainer {
    overflow: hidden;
  }

  #instructions {
    display: none;
  }

}

.spacer{
  height: 25px;
  display: block;
}

#IEMessage{
  color: red;
  font-size: 20px;

}

</style>

<div id='info'><div class="about"><input type="button" id="UnlockZoomBtn" name="UnlockZoomBtn" locked="false" value="Lock Zoom/Pan"/>
  <input type="button" id="updateResourcesBtn" name="updateResourcesBtn" value="Update Resources"/>
  <input type="button" id="clearOldBtn" name="clearOldBtn" value="Clear Finish < Today"/>

  <input type="button" id="updateChangedItemsBtn" name="updateChangedItemsBtn" value="Update Changed Items"/>

  <input type="button" id="getDataBtn" name="getDataBtn" value="Get Data"/>
    <input type="button" id="collisionBtn" name="collisionBtn" value="Collision Test"/>
  <input type="checkbox" name="MondayLock" id="MondayLock" checked='true' />Lock dragged Start to Monday ~
  <input type="checkbox" name="FridayLock" id="FridayLock" checked='true' />Lock dragged Finish to Friday ~
  <input type="checkbox" name="trainingProjects" id="trainingProjects" checked='true' />Use Training Projects ~
  <a id="instructions" href="http://tscppm/Help%20Wiki/Construction%20Planner.aspx" target="_blank">Click for instructions</a><br />
<div class='key'>Key (top right circle):
  <div id='circleKeyGreen'> </div> <span class="addDef">Issued for Construction</span> ~ <div id='circleKeyAqua'> </div> Design >75% Complete ~ <div id='circleKeyOrange' > </div> Design Started ~ <div id='circleKeySilver' > </div> Design NOT started </div>

</div>
<div id="IEMessage">This chart will not function in Internet Explorer - if viewing in IE, please reopen it in Google Chrome</div>

<div class=".slider-holder"></div>
<div class="spacer"></div></div>
<div id='chartContainer'>
<div class="chartAxisSpacer"></div>
<div class="chart"></div>
</div>
<script type="text/javascript">


// data

//const trainingProjects = true;
var trainingProjects = true;
//const checkme = "bb1";
//const XMLFileName = "/Data/Project Ready Matrix Data - Training.xml";
//const XMLFileName = "/Data/Project Ready Matrix Data.xml"
var XMLFileName = "/Data/Project Ready Matrix Data.xml"

var newName = "";

var pageX;




function runAfterEverythingElse() {
/* sliders */

var browser=get_browser();

if (browser.name != "Chrome") {
  alert("Incompatible browser detected ("+ browser.name+") - please reopen this chart in Chrome for full functionality.");

}

// if viewing in IE, code doesn't even get this far:
  $("#IEMessage").remove();


//var theFromSlider = d3.select('#slider6').call(d3.slider().axis(false).min(startYear).max(maxYear).step(1).value(thisYear).on("slide", function(evt, value) {

// GLOSSARY DEFINITION POPUP
jQuery(".addDef").addClass("ms-rteStyle-Accent1");

jQuery(".addDef").click(function() {
  var term = jQuery(this).text();
  var url = "/SitePages/ViewGlossary.aspx?Term="+term;
    OpenDialog(url);
  });

//////
//get currentUser up front because it can't be done fast enough during updates

var userid= _spPageContextInfo.userId;
var currentUser;
 var requestUri = _spPageContextInfo.webAbsoluteUrl + "/_api/web/getuserbyid(" + userid + ")";
 var requestHeaders = { "accept" : "application/json;odata=verbose" };
 $.ajax({
   url : requestUri,
   contentType : "application/json;odata=verbose",
   headers : requestHeaders,
   success : onSuccess,
   error : onError
 });

 function onSuccess(data, request){
   var loginName = data.d.Title;
   currentUser = loginName;

 }

 function onError(error) {
//   alert("error");
 }




$(document).mousemove(function(event) {
  pageX = event.pageX;
//  console.log(pageX);
})



  /*
   * decaffeinate suggestions:
   * DS102: Remove unnecessary code created because of implicit returns
   * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
   */


  var wrapper = document.querySelector('.chart');
  const width = wrapper.clientWidth;
//  var width = wrapper.clientWidth;
  const parser = d3.isoParse;
//  var parser = d3.isoParse;
  // stuff for resizing bars
var GROUP_HANDLE_H = 6;
var BAR_H = 30;

  var MAP_WIDTH = clWidth;
  var MAP_HEIGHT = clHeight;

  var MAX_TRANSLATE_X = MAP_WIDTH / 2;
  var MIN_TRANSLATE_X = -MAX_TRANSLATE_X;

  var MAX_TRANSLATE_Y = MAP_HEIGHT / 2;
  var MIN_TRANSLATE_Y = -MAX_TRANSLATE_Y;

  var MIN_RECT_WIDTH = 100;
   var MIN_RECT_HEIGHT = 100;


    var HANDLE_R = 5;
    var HANDLE_R_ACTIVE = 12;

    var activeNameGroupId = "";


//  const minX = d3.min(VEHICLES, d => parser(d.start));
//  const maxX = d3.max(VEHICLES, d => parser(d.end));

const minX = d3.min(MATRIXDATA, d => parser(convertSPDateOnly(d.StartDateExpression["#text"])));
const maxX = d3.max(MATRIXDATA, d => parser(convertSPDateOnly(d.FinishDateExpression["#text"])));

 //var minX = d3.min(MATRIXDATA, d => parser(convertSPDateOnly(d.StartDateExpression["#text"])));
//var maxX = d3.max(MATRIXDATA, d => parser(convertSPDateOnly(d.FinishDateExpression["#text"])));



  // --- X scale (nb: was const)
  var x = d3.scaleTime()
    .domain([minX, maxX])
    .rangeRound([0, width]);




/*    const xYear =  d3.scaleTime()
    .domain([minX, maxX])
    .rangeRound([0, width]); */ // not needed
  //const newData =
  // --- nest all the data
//    console.log(MATRIXDATA);
//http://bl.ocks.org/phoebebright/raw/3176159/
/*
// NOT USED ??
  const symbols = d3.nest()
    .key(d => d.UniqueReference["#text"] + "_" + d.ID ["#text"])
    .sortValues(function(a,b) {
      return ((a.AssignedToName < b.AssignedToName)
      ? -1
      : 1);
      return 0;})
    //  .key(d => d.UniqueReference["#ItemHref"])
//  .key(d => d.key)
    .entries(MATRIXDATA);
*/



//    console.log(symbols);

//    const symbolAssignees = d3.nest()
    var symbolAssignees = d3.nest()
      .key(d => d.AssignedToName).sortKeys(d3.ascending)
    //  .key(d => d.UniqueReference["#text"] + "_" + d.ID ["#text"])
     //UID
//      .key(d => convertSPDateOnly(d.StartDateExpression["text"]) + "_" +d.UniqueReference["#text"] + "_" + d.ID ["#text"]).sortKeys(d3.ascending)
      .key(d => d.UID).sortKeys(d3.ascending)
      // try not sorting, as already sorted b4
    //  .sortKeys(
    //    function(a,b) {
    //      return a.StartDateExpression["#text"] < b.StartDateExpression["#text"] //((a.StartDateExpression["#text"] < b.StartDateExpression["#text"])
        //  return((a.StartDateExpression["#text"] < b.StartDateExpression)
        /*  ? -1
          : 1);
          return 0; */
        //})
    //    d3.ascending)

      //  .key(d => d.UniqueReference["#ItemHref"])
    //  .key(d => d.key)
      .entries(MATRIXDATA);




    //  console.log(symbolAssignees);

  //console.log(symbolAssignees);

/*
var uniqueAssignees = symbols.forEach(function(d, i) {
    var name = d.key;
});
*/
//console.log(uniqueAssignees);

//var assignees = checkUnique(tempOwners);

  /*  const symbolsAssigned = d3.nest()
    .key(d => d.AssignedToName)
    .entries(symbols);
*/
//  const height = wrapper.getBoundingClientRect().bottom;
//var height = 25;
 const height = 25;
//  console.log(height);
  var spanX = d => x(parser(convertSPDateOnly(d.StartDateExpression["#text"])));
  var spanW = d => x(parser(convertSPDateOnly(d.FinishDateExpression["#text"]))) - x(parser(convertSPDateOnly(d.StartDateExpression["#text"])));


//  const spanX = (d, i) => x(parser(convertSPDateOnly(d.StartDateExpression["#text"])));
//  const spanW = (d, i) => x(parser(convertSPDateOnly(d.FinishDateExpression["#text"]))) - x(parser(convertSPDateOnly(d.StartDateExpression["#text"])));


/*
  //  // --- y scale
    const y = d3.scaleOrdinal()
      .domain(MATRIXDATA, d => d.AssignedTo["text"])
      .range([0, bBoxHeight]);
*/
//console.log("length:" + MATRIXDATA.length);
//console.log(MATRIXDATA);



  var colorScale = d3.scaleLinear()
      .domain([0, 3, MATRIXDATA.length])
      .interpolate(d3.interpolateHcl)
  //    .range(["#ffbfba","#ffffba","#bae1ff"]);
    .range(['rgba(255,191,186,0.7)','rgba(255,255,186,0.7)','rgba(186,255,255,0.7)']);

    var colorScaleNewSection = d3.scaleLinear()
        .domain([0, 3, 5])
        .interpolate(d3.interpolateHcl)
    //    .range(["#ffbfba","#ffffba","#bae1ff"]);
      .range(['rgba(255,255,204,0.7)','rgba(204,204,0,0.7)','rgba(173,255,47,0.7)']);


    var backColorScale = d3.scaleLinear()
        .domain([0, 4, MATRIXDATA.length])
        .interpolate(d3.interpolateHcl)
    //    .range(["#ffbfba","#ffffba","#bae1ff"]);
      .range(['rgba(255,191,186,0.4)','rgba(255,255,186,0.4)','rgba(186,255,255,0.4)']);







const label = function(symbol) {
  const svgL = d3.select(this.parentNode).selectAll('.AssignedGroup').append('g');
  //console.log(svgL)

  var lblText = symbol.key;

//console.log("got this far, name:" + lblText);


  svgL
  .attr("class", "labelGroup")
  .append('text')
  .text(lblText)
  .attr('class','labelText')
  .attr('width', '100')
  .attr("y", 20)
  .attr("font-size", 20)
  .attr("font-family", "sans-serif")
    .attr("font-weight", "bold")
  .attr('fill',function(d, i) {

        for (var i = 0; i < symbolAssignees.length; i++) {
          if (d.key.localeCompare(symbolAssignees[i].key) == 0) {
          //  for (var i = 0; i < MATRIXDATA.length; i++) {
          //    if (d.key.localeCompare(MATRIXDATA[i].undefined) == 0) {
      //if (d.key == symbolAssignees[i].key) {
            //    console.log("d.key:" + d.key + "; " + symbolAssignees[i].key);
            //    console.log(backColorScale(i));
        return d3.rgb(backColorScale(i)).darker(1.5);

      }
    }
  })
  //.attr('stroke','silver')
  .attr('opacity', '0.9')


  ;
//  .attr('z-index','9000')


svgL.append('line')
  .attr("class","divider")
  .attr("x1", x(minX))
  .attr("x2", x(maxX))
  .attr("stroke", "silver")
  .attr("stroke-width", 1)
    .attr("opacity", 0.5);



  return svgL;
}



const groupDragHandle = function(symbol) {
  var gpDim =computeDimensions(d3.select(this.parentNode).select('.AssignedGroup'));
  ///d3.select(this.parentNode).select('svg.AssignedGroup').bringToFront();
//  console.log(gpDim)
  //var gpHt = d3.select(this.parentNode).select('svg.AssignedGroup').height;
  //const svgDL = d3.select(this.parentNode).select('.AssignedGroup').append("rect"); //.append('g');
  const svgDL = d3.select(this.parentNode).select('.AssignedGroup').append("rect"); //.append('g');

  svgDL.attr("class", "dragbottom")
      .attr("height", GROUP_HANDLE_H)
      .attr('x', 0)
      .attr('y', function (d,i) {
      //  i++;
    //  console.log(d);
        return height*(i)+gpDim.height;
      })
//.attr('width', d => spanW(d))
      .attr('width', '100%')


      //  .attr("width", dragbarw)
            .attr("fill", "blue")
            .attr("fill-opacity", .4)
            .attr("cursor", "ns-resize")
          //  .on("drag", bdragresize);
        .on("drag", d3.drag());
        //  .call("drag", d3.drag());
        //    .moveToFront();

  return svgDL;
}



var previousBar;


// WHERE TO BREAK THIS UP
function drawChart() {

console.log('redrawing the chart')
var chart =  function(symbol) {
  var svgB = d3.select(this);


var dindex=0;
var bindex=0;
   svgB.selectAll('rect')
    .data(symbol)

    .enter()
    .append('g')
    .attr('class', 'projectBar')
  //  .attr('dataIndex',function(a,k){ return k;})
    .data(symbol.values)

    .enter()

    .selectAll('rect')

    .data(function(d,i) {
      return d.values
    })

    .enter()

    .append('g')
    .attr('class', 'GBarGroup')
    //    .attr('x', d => spanX(d)) //adding x to the group so maybe it will help me later
  //  .attr('bar-data-index', function(d,i) {return i;})
      .attr('bar-data-index', function() {
        return bindex++;
      })

    .attr("startDate", function(d) {
      //console.log(d.StartDateExpression["#text"])
      return d.StartDateExpression["#text"]
    })
    .append('svg')
     .attr("rx", 6)
    .attr("ry", 6)
    .attr('x', d => spanX(d))
   .attr('y', function (d, i) {
     //space out the bars

      if (dindex == 0) { // first one
        dindex++;
      } else {
  if (i > 0) {
    //console.log(d[i].DueDate, d[i-1].DueDate);
//    console.log(d.FinishDateExpression);
    try {
    //  console.log(d[i-1].FinishDateExpression);
    } catch (ex) {
    //  console.log('previous data not found');
    }
  }
    dindex++;
      }
      return height*(dindex-1);

    })
    //.attr('width', d => spanW(d))
    .attr('width', d => spanW(d))
//    .attr('height', height)
//  .attr('height', (d, i) => 25*i)

    .attr('class','barGroup')
      .on("mouseenter mouseleave", groupHover)
      .call(d3.drag())
    .append('rect')

      .attr("class", "bars")
  //    .attr("overflow", "visible")
      .attr("rx", 6)
      .attr("ry", 6)
      .attr('width', d => spanW(d))
      .attr('height', height)
    /*  .attr('fill',  d => d.color || '#ddf') */
    .attr('fill', function(d) {

      for (var i = 0; i < MATRIXDATA.length; i++) {
    if (d.UniqueReference["#text"] == MATRIXDATA[i].UniqueReference["#text"]) {
      return d3.rgb(colorScale(i));
    }
    };
    } )
     .attr('stroke', function(d) {

       for (var i = 0; i < MATRIXDATA.length; i++) {
     if (d.UniqueReference["#text"] == MATRIXDATA[i].UniqueReference["#text"]) {
       return d3.rgb(colorScale(i)).darker(0.5);
     }
     };
     })
   .on("mousedown.zoom", null);


   svgB.selectAll('.barGroup')
   .append('text')
   .text(function (d) {
   //  return d.UniqueReference["#text"] + "-" + d.AssignedTo["#text"];
         return d.UniqueReference["#text"] + "-" + d.AssignedToName  + " ("+ d.OwnerName + ")-" + d.WebName["#text"];
 //    return d.UniqueReference["#text"] + "-" + d.WebName["#text"];
   })
   .attr("class", "barsText")
     .attr("rx", 6)
     .attr("ry", 6)
     //.attr('x', 100)
   //  .attr('x', d => spanX(d.UniqueReference["#text"]))
    // .attr('x', d => spanX(d)+10)
     .attr('y', 12)
   /*  .attr("transform", function(d) { return "translate(" + spanX(convertSPDateOnly(d.StartDateExpression["#text"])) + ")"; }) */
     .attr("font-size", 9)
     .attr("font-family", "sans-serif")
 //   .attr('width', d => spanW(d))
     .attr('width', width)
     .attr('fill', function(d) {
       //  console.log(d);
       for (var i = 0; i < MATRIXDATA.length; i++) {
     if (d.UniqueReference["#text"] == MATRIXDATA[i].UniqueReference["#text"]) {
       return d3.rgb(colorScale(i)).darker(2);
     }
   }
 });


     svgB.selectAll('.barGroup')
     .append('circle')
     .attr('cx',  d => spanW(d))
     .attr('class','circHandle')

     //.attr('cy', 6)
     .attr('cy', height )
     .attr('y', 20)
      .attr('r', HANDLE_R)
      .on("mouseenter mouseleave", resizerHover)
      .on('click', function() {
        alert('resize handle clicked')
      })
      .on('drag', rectResizing)
     .attr('fill', 'pink')
     .attr('opacity','0.5');
//     .call(d3.drag());


      svgB.selectAll('.barGroup')
      .append('text')
      .attr('class','completedText')
      .attr('x',-HANDLE_R+1)
      .attr('y',HANDLE_R)
      /*.attr('height',0)
      .attr('width', 0) */
      .html('&#10004;'); // tick character
      svgB.selectAll('.barGroup')
      .append('circle')
      .attr('cx', 0 )
      .attr('class','circComplete')
      .attr('cy', 0)
      .attr('y', 20)
      .attr('r',HANDLE_R)
      .on("mouseenter mouseleave", finishHover)
      .on('click', function() {
        d3.event.stopPropagation();

        var resp = confirm("Click OK mark this construction job as Completed.\n\nCompleted items have a green border\n\nClick the 'Update Changed Items' button to send all changes to BrightWork.");

        if (resp == 1) {

        //alert('coming soon:finish clicked');
      //  var closeBar = $(this).closest("g.GBarGroup");  //WORKS
          var closeBar = d3.select(this.parentNode);  //WORKS
        console.log("closeBar data ...: ");
            var closeData = closeBar.data();
          //  var closeData = d3.select(closeBar).data();
            console.log(closeData);
            closeData[0].newCompletion = "1";
              d3.select(this.parentNode).select('rect').classed("changed", true); // to pick it up in the update part of the code
            d3.select(this.parentNode).select('rect').classed("completed", true);  // to show it as green not red
          //closeBar.classed("changed", true);
        } //end resp =1

      })
      .attr("fill","#dda0dd")
      .attr("opacity",0.5);



      svgB.selectAll('.barGroup')
      .append('text')
      .attr('class','removeText')
      .attr('x',-HANDLE_R+1)
      .attr('y',height+HANDLE_R/2)
      /*.attr('height',0)
      .attr('width', 0) */
      .html('&#10008;'); // tick character
      svgB.selectAll('.barGroup')
      .append('circle')
      .attr('cx', 0 )
      .attr('class','circRemove')
      .attr('cy', height)
      .attr('y', height)
      .attr('r',HANDLE_R)
      .on("mouseenter mouseleave", finishHover)
      .on('click', function() {
        d3.event.stopPropagation();

        var resp = confirm("Click OK to remove this task from the chart.");

        if (resp == 1) {

        var closeBar = this.closest("g.GBarGroup").remove();  //WORKS

        } //end resp =1

      })
      .attr("fill","silver")
      .attr("opacity",0.5);




//.attr("filter", "url(http://tscppm/SiteAssets/scripts/prettyGantt/greencheck36x36.png)");

/*
svgB.selectAll('.barGroup')
.append('image')
.attr("xlink:href", "/SiteAssets/scripts/prettyGantt/greencheck.png")
.attr('x', -HANDLE_R/2)
.attr('y', -HANDLE_R/2)
.attr('class','circComplete')
.attr('width',HANDLE_R*2)
.attr('height', HANDLE_R*2)
.on("mouseenter mouseleave", finishHover)
.on('click', function() {
  d3.event.stopPropagation();
  alert('coming soon:finish clicked');
});
*/
     svgB.selectAll('.barGroup')
     .append('circle')
     .attr('cx',  d => spanW(d))
     .attr('class','circInfo')

     //.attr('cy', 6)
     .attr('cy', 0 )
     .attr('y', 20)
      .attr('r', HANDLE_R)
      .on("mouseenter mouseleave", infoHover)
      .on('click', function() {
        d3.event.stopPropagation();
        var theData = d3.select(this.parentNode).datum();

        newStart = "";
        newFinish = "";
        newDurationText="";

      if (theData.hasOwnProperty("newStartDate")) {
        newStart = " (changed to: "+ theData.newStartDate+")"
      };

      if (theData.hasOwnProperty("newFinishDate")) {
        newFinish = " (changed to: "+ theData.newFinishDate+")"
      };

      if (theData.hasOwnProperty("newDuration")) {
        newDurationText = " (changed to: "+ theData.newDuration+")"
      };


        console.log("newfinish:" + theData.newFinishDate);
        delete theData["#text"];
        var theString =
        "<table class='projectInfo'>" +
        "<tr><th>Project:</th><td>" +
        theData.WebName["#text"] + "</td></tr>" +
                "<tr><th>Start:</th><td>" +
        convertSPDateOnly(theData.StartDateExpression["#text"])+newStart + "</td></tr>" +
  "<tr><th>Finish:</th><td>" +
        convertSPDateOnly(theData.FinishDateExpression["#text"])+newFinish + "</td></tr>" +
        "<tr><th>Duration:</th><td>" +
              theData.EstDurationAtCompletion["#text"] + newDurationText + "</td></tr>" +
        "<tr><th>Design status:</th><td>" +
              theData.DesignStatus+ "</td></tr>" +
              "<tr><th>Approval status:</th><td>" +
                    theData.ApprovalStatus+ "</td></tr>" +
                              "<tr><th>Assigned to:</th><td>" +
        theData.AssignedToName + "</td></tr>" +
                        "<tr><th>Links:</th><td>" +
        "<a href='"+theData.ItemHref["#text"]+"' target='_blank'>construction task item</a>" + "</td></tr>" +
        "</table>";
        ;
        var thetitle = theData.UniqueReference["#text"];
      //  console.log(theData);
        //  alert(JSON.stringify(theData));
        //NB: bELOW COMES FROM SPAlerts.js which is embedded as a SP ScriptLink on this site
        LaunchMessageDialog(thetitle,theString, null);
        //alert(theString);
      })
     .attr('fill', function(d) {
       var statusInt = parseFloat(d.DesignStatus);
       var statusIntAppr = parseFloat(d.ApprovalStatus);
       if (statusIntAppr > -1 && statusIntAppr < 1 && statusInt == 1) {
         statusInt = 0.85;
       }
       if (statusIntAppr == 1) {
         statusInt = (statusInt + statusIntAppr)/2;
       }
       //console.log(d.esignStatus);
       if(statusInt == 1) {
         return "lime";
       } else
       if (statusInt >= 0.75 && statusInt < 1 ){
         return "aqua";
       }
       if (statusInt > 0 && statusInt < 0.75 ){
         return "DarkOrange";
       } else {
         return "Silver";
       }

     })
     .attr('opacity','0.4');
      //   .call(d3.drag()); //this is only circinfo, don't want to be able to drag this corner

  return svgB;
};






function length(obj) {
    return Object.keys(obj).length;
}







// THIS DOES ADD SOME TEXT TO TOP OF PAGE - COULD MOVE IT BY TRANSFORM, WANT TO TRY AND KEEP IT WITH THE RECTS IF POSSIBLE
/*
console.log(symbols);
d3.select(wrapper).selectAll('svg')
.data(symbols)
.enter()
.append('text')
//.attr('x', d => spanX(d[0].StartDateExpression["#text"]))
.attr('x', 0)
.attr('y', 0)
.attr("dy", ".35em")
.text(function(d) {
//  return d.key;
  return d.values[0].UniqueReference["#text"];
//console.log(d);
//  return "some text"; //d[0].ListName["#text"];
  //return d.UniqueReference["#text"];
});
*/

//};


/*
function dragstarted(d) {
  d3.select(this).raise().classed("active", true);
}

function dragged(d) {
  d3.select(this).select("text").attr("x", d.x = d3.event.x).attr("y", d.y = d3.event.y);
  d3.select(this).select("rect").attr("x", d.x = d3.event.x).attr("y", d.y = d3.event.y);
}

function dragended(d) {
  d3.select(this).classed("active", false);
}
*/




  // --- add all charts


//const
// allCharts = d3.select(wrapper).selectAll('.AssignedGroup')
//spacer for header
d3.select('.chart').select('svg').append('svg')
.attr('height', weekLabelHeight);

  allCharts = d3.select(wrapper)
    .selectAll('g')
      .data(symbolAssignees)
      .enter()
      .append('g')
      .attr('class','assignedGroupGp')
      .attr('id', function(d,i) {
        return "assignedto-"+d.key;
      })
     .append('svg')
      .attr('class','AssignedGroup')
      .on("click", function(d) {
          //  d3.event.stopPropagation();
            var gpDim = computeDimensions(d3.select(this));
            var gpHeight = d3.select(this).attr("height");
              gpY = gpDim.y;
            var gpName = d3.select(this).attr("assignedName");

                d3.select(this).lower();
                newName = gpName;
                activeNameGroup = this.closest("g.assignedGroupGp");
                activeNameGroupId = d3.select(activeNameGroup).attr("ID");
              //  d3.select(".AssignedGroup").attr("pointer-events","stroke"); //restore pointer events
              //  console.log("this.pointer-events:" + d3.select(this).attr("pointer-events"));
              //  d3.select(this).attr("pointer-events","stroke");

            //    d3.select(activeNameGroup).moveToFront();

        //    if (d3.select(this).select('.labelGroup').select('text').classed("darker")) {

        //      d3.select(this).select('.labelGroup').select('text').classed("darker", false);
              // already activated, deactivate it
        //    } else {
/*
            if ( confirm("Increase grid height for "+ gpName +"?")) {

              numIncreases++;

              d3.select(this).attr("height", parseInt(gpHeight) + height);
            //  console.log("class:"+d3.select(this).attr("class"));
              d3.selectAll(".labelText").classed("darker", false);
              d3.select(this).select('.labelGroup').select('text').classed("darker", true);
              console.log("increasing height");

              //calculateAndApplyHeight();

              //xAxisWeekFloating.tickSize(xAxisWeekFloating.tickSize()+height);
              //xAxisWeekFloating3.tickSize(xAxisWeekFloating3.tickSize()+height);


              wrapper = document.querySelector('.chart');
              infowrapper = document.querySelector('#info');

              wrapperDetails = wrapper.getBoundingClientRect();
              infoDetails = infowrapper.getBoundingClientRect();

              bBoxHeight = wrapperDetails.height;

              xAxisWeekFloating.tickSize((bBoxHeight-infoDetails.height));
              xAxisWeekFloating3.tickSize((bBoxHeight-infoDetails.height+20));


              globalXWeekFloating3.call(xAxisWeekFloating3);
              globalXWeekFloating.call(xAxisWeekFloating);

                  d3.select(this).moveToBack();

                      //          calculateAndApplyHeight();

            } else {
          //    assignedName = d3.select(this.attr("assignedName"));
              console.log("name:" + gpName);

            //  console.log("class:"+d3.select(this).attr("class"));
              d3.selectAll(".labelText").classed("darker", false);
              d3.select(this).select('.labelGroup').select('text').classed("darker", true);

              d3.select(this).moveToBack();

            }

*/
            var closeBar = this.closest("g.GBarGroup");
           d3.select("g.GBarGroup").sort(function (a, b) { // select the parent and sort the path's
             if (a != closeBar) return -1;               // a is not the hovered element, send "a" to the back
             else return 1;                             // a is the hovered element, bring "a" to the front


         });
//} // end of checking the class

      } )
  //    .on('mouseover', function() { return d3.select(this).lower();})
      .attr('assignedName', function(d) {
    //    console.log(d);
        return d.key;
      })
    //  .attr('height', 'auto')
     .attr('height', function(d, i){
      //  console.log(d.values.length);
      //  console.log(d);
      //  console.log(d.values.length*25);
        return d.values.length*BAR_H;
      //  return (i+1)*height;
    })
    .attr('x',"0")
    .attr('y', function(d, i) {
      if (i > 0)
      {
        return symbolAssignees[i-1].values.length*BAR_H+1;
      } else {
        return 0;
      }
    })
     .attr('data-length', function (d, i)
      { return d.values.length; })
      .attr('name-data-index', function (d, i)
       { return i; })
       /*
      .attr('background', function(d) {
        //  console.log(d);
        for (var i = 0; i < symbolAssignees.length; i++) {
      if (d.key == symbolAssignees[i].key) {
        return d3.rgb(colorScale(i));
      }
     }
   }) */
      .style("background-color", function(d, i) {
        for (var i = 0; i < symbolAssignees.length; i++) {
          if (d.key.localeCompare(symbolAssignees[i].key) == 0) {
      //if (d.key == symbolAssignees[i].key) {
            //    console.log("d.key:" + d.key + "; " + symbolAssignees[i].key);
            //    console.log(backColorScale(i));
        return backColorScale(i);
      }
      }
      })
      //.each(AssigneeGroups)

      // this is each assigned to chunk


        .each(chart)
    //    .each(groupDragHandle)
        .each(label);
      //  .each(groupDragHandle);


    /*  // HERE'S THE 'TODAY' LINE

        var today = new Date();
        var xNow = x(today);
      //    allCharts.append("line").attr("class","today").attr("x1", xNow) //<<== change your code here
        d3.select('.chart').append("line").attr("class","today").attr("x1", xNow) //<<== change your code here
          .attr("y1", 0).attr("x2", xNow) //<<== and here
          .attr("y2", bBoxHeight).style("stroke-width", 2).style("stroke", "red").style("fill", "none");
*/
//allCharts.each(groupDragHandle);


      //  .each(chartText);
    //   .each(dragbarbottom)


        allCharts.on("mouseover", function(d) {
      //    console.log('moused over');
            var closeBar = this.closest("g.GBarGroup");
          //  console.log(closeBar);
          //  d3.selectAll("path").sort(function (a, b) { // select the parent and sort the path's
            d3.select("g.GBarGroup").sort(function (a, b) { // select the parent and sort the path's
              if (a != closeBar) return -1;               // a is not the hovered element, send "a" to the back
              else return 1;                             // a is the hovered element, bring "a" to the front
          });
        });










} //END DRAWCHART

var allCharts;

drawChart();

var numIncreases = 0;




function dragstarted() {
  console.log("drag started");
}

function dragged() {
  // does work but the location is off
  console.log("draged");
  // console.log(d3.select(this.closest('svg')));
//  d3.select(this).selectAll('path').attr("x", d.x = d3.event.x).attr("y", d.y = d3.event.y);
d3.select(this.closest('g')).selectAll("text").attr("x", d.x = d3.event.x).attr("y", d.y = d3.event.y);
d3.select(this.closest('g')).selectAll("rect").attr("x", d.x = d3.event.x).attr("y", d.y = d3.event.y);


}


function dragended() {
  console.log("drag ended");
}


















// slider
//var data3 = d3.range(0, 10).map(function (d) { return new Date(1995 + d, 10, 3); });
//const dataYears = d3.nest()
/*
const dataYears = d3.nest()
.key(function(d) { return parser(convertSPDateOnly(d.StartDateExpression["#text"]));})
.value(function(d) { return parser(convertSPDateOnly(d.StartDateExpression["#text"]));})
.rollup(function(d) {
return d3.sum(d, function(g) {return g.value ; });
}).entries(MATRIXDATA);
*/
/*
var yearData = [];
symbols.forEach(function(d){
try {
//console.log(d.values[0]);
var dateVal = d.values[0].StartDateExpression["#text"];
var year = dateVal.substring(0,4);
console.log(year);

yearData.indexOf(year) === -1 ? yearData.push(year) : console.log("This item already exists");
} catch (ex) {}
});

console.log(yearData);
const minYear = new Date(parseInt(d3.min(yearData)),1,1);
const maxYear = new Date(parseInt(d3.max(yearData)),12,31);

console.log(minYear);
console.log(maxYear);
var slider3 = d3.sliderHorizontal()
.min(minYear)
.max(maxYear)

//.step(24 * 365)
.step(1000 * 60 * 60 * 24 * 365)
.width(400)
.tickFormat(d3.timeFormat('%Y'))
//  .tickValues(yearData)
//  .ticks(d3.timeYear.every(1))
//.tickValues(MATRIXDATA, d => parser(convertSPDateOnly(d.StartDateExpression["#text"])))
.on('onchange', val => {
  d3.select("span#value3").text(d3.timeFormat('%Y')(val));
});

var group3 = d3.select("div#slider3").append("svg")
.attr("width", 500)
.attr("height", 20)
.append("g")
.attr("transform", "translate(30,30)");

group3.call(slider3);

d3.select("span#value3").text(d3.timeFormat('%Y')(slider3.value()));
d3.select("a#setValue3").on("click", () => { slider3.value(new Date()); d3.event.preventDefault(); });
*/

var v1=3,
v2=7;

//setupSlider(v1, v2, updateGraph, color);
setupSlider(v1, v2);

//function setupSlider(v1, v2, updateGraph, color){
function setupSlider(v1, v2){

var sliderVals=[v1, v2],
  width = 400,
  svg = d3.select(".slider-holder").append("svg")
//  svg = d3.select(wrapper).append("svg")
    .attr('width', width+30)
    .attr('height', 50);

var x = d3.scaleLinear()
  .domain([0, 10])
  .range([0, width])
  .clamp(true);

var xMin=x(0),
  xMax=x(10)

var slider = svg.append("g")
  .attr("class", "slider")
  .attr("transform", "translate(5,20)");

slider.append("line")
  .attr("class", "track")
  .attr("x1", 10+x.range()[0])
  .attr("x2", 10+x.range()[1])

var selRange = slider.append("line")
  .attr("class", "sel-range")
  .attr("x1", 10+x(sliderVals[0]))
  .attr("x2", 10+x(sliderVals[1]))

slider.insert("g", ".track-overlay")
  .attr("class", "ticks")
  .attr("transform", "translate(10,24)")
.selectAll("text")
.data(x.ticks(10))
.enter().append("text")
  .attr("x", x)
  .attr("text-anchor", "middle")
  .style("font-weight", "bold")
  .style("fill", "blue")
//  .style("fill", function(x){return color(x);})
  .text(function(d) { return d; });

var handle = slider.selectAll("rect")
.data([0, 1])
.enter().append("rect", ".track-overlay")
  .attr("class", "handle")
  .attr("y", -8)
  .attr("x", function(d) { return x(sliderVals[d]); })
  .attr("rx", 3)
  .attr("height", 16)
  .attr("width", 20)
  .call(
      d3.drag()
        .on("start", startDrag)
        .on("drag", drag)
        .on("end", endDrag)
  );

function startDrag(){
d3.select(this).raise().classed("active", true);
}

function drag(d){
var x1=d3.event.x;
if(x1>xMax){
  x1=xMax
}else if(x1<xMin){
  x1=xMin
}
d3.select(this).attr("x", x1);
var x2=x(sliderVals[d==0?1:0])
selRange
    .attr("x1", 10+x1)
    .attr("x2", 10+x2)
}

function endDrag(d){
var v=Math.round(x.invert(d3.event.x))
var elem=d3.select(this)
sliderVals[d] = v
var v1=Math.min(sliderVals[0], sliderVals[1]),
    v2=Math.max(sliderVals[0], sliderVals[1]);
elem.classed("active", false)
  .attr("x", x(v));
selRange
    .attr("x1", 10+x(v1))
    .attr("x2", 10+x(v2))

//  updateGraph(v1, v2);
}

}






var clHeight = wrapper.clientHeight;
var clWidth = wrapper.clientWidth;
//var clHeight2 = wrapper.attr("height");
var bBoxHeight = wrapper.getBoundingClientRect().height;
var bBoxTop = wrapper.getBoundingClientRect().top;
//console.log(wrapper.getBoundingClientRect());
var yearFormat = d3.timeFormat("%Y");
var weekFormat = d3.timeFormat('%y-%W');
//var weekNumFormat = d3.timeFormat('%W');

var weekOnlyFormat = d3.timeFormat('%W');
//var weekFormat = d3.timeFormat()

var wHeight = window.innerHeight;

//console.log(bBoxHeight);
//console.log(clHeight);
//console.log(wrapper);






//AXES
/*
const axisWrapper = d3.select(wrapper)
.append('g')
.attr('class', 'axisWrapper');
*/
// --- add X axis
var xAxis = d3.axisBottom(x)
      .ticks(width / 100);

var xAxisYear = d3.axisBottom(x)
          .ticks(d3.timeYear.every(1))
          .tickFormat(yearFormat);


  var xAxisWeek = d3.axisBottom(x)
        //  .ticks(d3.fridayOfYear)
        .ticks(d3.timeWeek)
          .tickFormat(weekFormat);
                  /*    .tickFormat(function(d) {
                        getFiscalWeekNumber(d3.time.week(day));
                      }); */


//xAxis code to give ticks every N-th day: .ticks(d3.timeDay.filter(d=>d3.timeDay.count(0, d) % N === 0))
var weekLabelHeight = 0;

var xAxisWeekFloating = d3.axisTop(x)
//.ticks(d3.timeWeek)
// nb % 2 means display every second week
.ticks(d3.timeWeek.filter(d=>d3.timeWeek.count(0, d) % 2 === 0))
.tickSize(clHeight - weekLabelHeight)
.tickFormat(weekOnlyFormat);

var xAxisWeekFloating3 = d3.axisTop(x)
//.ticks(d3.timeWeek)
// nb % 2 means display every second week
.ticks(d3.timeWeek.filter(d=>d3.timeWeek.count(0, d) % 2 === 1))
//.tickSize(clHeight - weekLabelHeight)
.tickSize(bBoxHeight+20)
.tickFormat(weekOnlyFormat);

var xAxisWeekFloating2 = d3.axisTop(x)
//.ticks(d3.timeWeek)
// nb % 2 means display every second week
.ticks(d3.timeWeek.filter(d=>d3.timeWeek.count(0, d) % 2 === 0))
.tickSize(0)
.tickFormat(weekOnlyFormat);


var axisCont = d3.select('.chart')
.append('g')
.attr('class', 'axisContainer');

var globalXWeekFloating = axisCont //d3.select('.chart.axisContainer')
.append('svg')
.attr('class', 'axisWeekFloating')
//.attr('height', 20)
//   .style('fill', 'white')

//.attr("transform",  "translate(0, -"+weekLabelHeight+")")
.call(xAxisWeekFloating);


var globalXWeekFloating3 = axisCont //d3.select('.chart.axisContainer')
.append('svg')
.attr('class', 'axisWeekFloating3')
.call(xAxisWeekFloating3);

globalXWeekFloating3.selectAll("text").remove();

/*
var globalXWeekFloating2 = axisCont //d3.select('.chart.axisContainer')
.append('svg')
.attr('class', 'axisWeekFloating2')
//.attr('height', 20)
//   .style('fill', 'white')

// .attr("transform",  "translate(0, -"+weekLabelHeight+")")
.call(xAxisWeekFloating2);
*/


var globalX = axisCont //d3.select('.chart.axisContainer')
              .append('svg')
              .attr('class', 'axis')
              .call(xAxis);


              var globalXWeek = axisCont // d3.select('.chart.axisContainer')
                        .append('svg')
                        .attr('class', 'axisWeek')
                      .attr('height', 20)
                      //   .style('fill', 'white')

                        .attr("transform",  "translate(0, -20)")
                        .call(xAxisWeek);



/// END OF AXIS



function calculateAndApplyHeight(extra) {
  wrapper = document.querySelector('.chart');
  infowrapper = document.querySelector('#info');

  wrapperDetails = wrapper.getBoundingClientRect();
  infoDetails = infowrapper.getBoundingClientRect();

  bBoxHeight = wrapperDetails.height;

//  xAxisWeekFloating.tickSize((bBoxHeight-infoDetails.height+300));
//xAxisWeekFloating3.tickSize((bBoxHeight-infoDetails.height-30-20));

xAxisWeekFloating.tickSize((bBoxHeight-infoDetails.height));
xAxisWeekFloating3.tickSize((bBoxHeight-infoDetails.height));

//xAxisWeekFloating.tickSize((bBoxHeight+20));
//xAxisWeekFloating3.tickSize((bBoxHeight+20));

  globalXWeekFloating3.call(xAxisWeekFloating3);
  globalXWeekFloating.call(xAxisWeekFloating);

//  globalXWeekFloating3.call(xAxisWeekFloating3.scale(transform.rescaleX(x)));
//globalXWeekFloating.call(xAxisWeekFloating.scale(transform.rescaleX(x)));
}





//var bars = allCharts.selectAll('rect');
var bars = allCharts.selectAll('rect');
var barGroups = allCharts.selectAll('.barGroup');
var nameGroups = d3.selectAll('.AssignedGroup');
var circles = allCharts.selectAll('circle');


function makeAbsoluteContext(element, svgDocument) {
  return function(x,y) {
    var offset = svgDocument.getBoundingClientRect();
    var matrix = element.getScreenCTM();
    return {
      x: (matrix.a * x) + (matrix.c * y) + matrix.e - offset.left,
      y: (matrix.b * x) + (matrix.d * y) + matrix.f - offset.top
    };
  };
}

/*
var groupResizeDragHandler = d3.drag()
.on("start", function(d){
  console.log("started dragging:" + d3.event.y);
})
.on("drag", function(d) {
d3.select(this).attr("y") = d3.event.y;
})
.on("end", function(d) {

});



nameGroups = allCharts.selectAll('.AssignedGroup'); // get them afresh .. don't now if i need to do that
 groupResizeDragHandler(nameGroups);

*/

var deltaX, deltaY, deltaW;
var parentSvg;
var thisOffsetX, thisOffsetY;


var current, currentParent;


var dragHandler = d3.drag()
    .on("start", function (d) {

      console.log("dragging");
    //  var current=d3.select(this);
        var current=d3.select(this);
      var currentParent=d3.select(this.parentNode);
      console.log("this class:" + current.attr("class"));
      console.log("parent class:" + currentParent.attr("class"));
  //    deltaX = current.attr("x");// - d3.event.x; //restore without -xxx if can't make ot work
    //  deltaY = current.attr("y");// - d3.event.y;//restore without -xxx if can't make ot work



  if (d3.select(this).classed("AssignedGroup") == true) {

    thisOffsetY = current.attr("height") - d3.event.y;
  } else {


    thisDimensions = computeDimensions(currentParent);
    thisOffsetX = d3.event.x - thisDimensions.x-HANDLE_R;
    thisOffsetY = d3.event.y - thisDimensions.y-HANDLE_R;
  //  deltaXparent = currentParent.attr("x");//- d3.event.x;//restore without -xxx if can't make ot work
  //  deltaYparent = currentParent.attr("y");// - d3.event.y;//restore without -xxx if can't make ot work

    //deltaXparent = currentParent.attr("x") - d3.event.x;
  //  deltaYparent = currentParent.attr("y") - d3.event.y;
  var newX = d3.event.x - thisOffsetX;


  /*
        console.log("deltaX at start:" + deltaX);
        console.log("deltaXparent at start:" + deltaXparent);
  */
        console.log("d3.event.x at start:"+d3.event.x);
        console.log("d3.event.y at start:"+d3.event.y);

        console.log("offset x at start:"+thisOffsetX);
        console.log("offset y at start:"+thisOffsetY);

  }

//  d3.select(this.rootNode.appendChild(this.parentNode));
  //    console.log("parentNode Before:" + d3.select(this.parentNode.parentNode).attr("class"));
    //  if (d3.select(this.parentNode.parentNode).classed("Assigned"))
    //  {
        // attempt to stop random bar jumping = DIDN'T SEEM TO DO ANYTHING USEFUL
      //  d3.select(this.parentNode.parentNode.appendChild(this.parentNode));
      //  console.log("parentNode After:" + d3.select(this.parentNode.parentNode).attr("class"));
    //  }
//  d3.select(this.parentNode).moveToFront;

  //d3.select('.chart').appendChild(this.parentNode);

    })
    // no need, dragging the copy NOW (not a copy, have put the node back on top actually)

    .on("drag", function () {
  //getAllElementsFromPoint(d3.event.x, d3.event.y);

//pageX = d3.event.pageX;
//if (d3.select(this).classed("AssignedGroup") == true || d3.select(this).classed("dragbottom") == true) {
  if (d3.select(this).classed("AssignedGroup") == true) { // dragbottom gone for now .. may not bring back


  //console.log("true dragbottom");
//console.log(d3.select(this).attr("class"));

/*  d3.select(this).select(".dragbottom")
//  .moveToFront()

  //    .attr("x", d3.event.x + deltaX)
      .attr("y", d3.event.y-GROUP_HANDLE_H)
      .moveToFront();
*/
  d3.select(this).attr("height", d3.max([BAR_H,d3.event.y+thisOffsetY]));

} else {

//console.log("not dragbottom");

//d3.select(this.parentNode).attr("transform", "translate("+d3.event.translate+")");


d3.select(this)
      .attr("x", d3.event.x-thisOffsetX)//restore without + deltaX if can't make ot work
      .attr("y", d3.event.y-thisOffsetY);// - deltaY); //restore without +deltaY if can't make ot work
    //  .attr("x", d3.event.x)
    //  .attr("y", d3.event.y);


     } // end if not dragbottom
    })
    .on("end", function(d){


      // find the new bar locations
    //  passThruEvents(d3.select(this.parentNode));
  // ALL DATA:
//  console.log(d.x)
//   passThruToGroup(deltaX, deltaY);


//   d3.select(this)
//   .moveToFront()




  //if (d3.select(this).classed("AssignedGroup") == true || d3.select(this).classed("dragbottom") == true) {
  if (d3.select(this).classed("AssignedGroup") == true) {   // || d3.select(this).classed("dragbottom") == true) {

d3.selectAll('.labelGroup').select('text').classed("darker", false);
d3.select(this).select('.labelGroup').select('text').classed("darker", true);

var gpName = d3.select(this).attr("assignedName");

  //d3.select(this).lower();
    newName = gpName;
    activeNameGroup = this.closest("g.assignedGroupGp");
    activeNameGroupId = d3.select(activeNameGroup).attr("ID");
    //var thisNode = d3.select(this.parentNode);  // actualy its the assigned group thats being dragged
    // console.log("assname:" + thisNode.attr("assignedName"));
    console.log("yes this is dragbottom");
    //console.log("oldScale:" + oldScale)
    var trimmedHeight;
    d3.select(this).attr("height", function(d) {
      untrimmedHeight = parseInt(d3.select(this).attr("height"));
      trimmedHeight = parseInt(untrimmedHeight -untrimmedHeight%(BAR_H/oldScale));
      return trimmedHeight;
    });
    d3.select(this).select('.today').attr('y2', trimmedHeight);
    var newDataLength = parseInt(trimmedHeight/BAR_H/oldScale);
    d3.select(this).attr("data-length", newDataLength);

/*
// no dragbottom at the moment
    d3.select(this).select(".dragbottom")
  //  .moveToFront()

    //    .attr("x", d3.event.x + deltaX)
        .attr("y", trimmedHeight-GROUP_HANDLE_H)
        .moveToFront();
*/

      /*  xAxisWeekFloating.tickSize(xAxisWeekFloating.tickSize()+trimmedHeight);
        xAxisWeekFloating3.tickSize(xAxisWeekFloating3.tickSize()+trimmedHeight);

        globalXWeekFloating3.call(xAxisWeekFloating3);
        globalXWeekFloating.call(xAxisWeekFloating);
         */

      //   calculateAndApplyHeight(BAR_H);
                  calculateAndApplyHeight(BAR_H);
        //    d3.select(this).moveToBack();

    /*  var groups = d3.selectAll(".AssignedGroup")
    .filter(function(d, i) {
    //  console.log(d);
      return d.key != thisNode.attr("assignedName");
      // return i != 2;
     });
     //console.log('exclude one group:');
     //console.log(groups);
    d3.selectAll(groups.parentNode).moveToBack(); */
 //d3.select(this).moveToFront();


   } else {

      console.log("drag ended, get a new date");

      d3.select(this).select('rect').classed("changed", true);
      //   d3.selectAll(groups.parentNode).moveToBack();
      d3.select(this).moveToFront();

//    console.log(d3.selectAll('.GBarGroup').data()); // WORKS
    // THIS BAR'S DATA
      var closeBar = this.closest("g.GBarGroup");  //WORKS

         colVal = collisionDetection(d3.select(closeBar).select('.barGroup'));
         console.log("collision result:" + colVal);
    //  closeBar.moveToFront();
  //  d3.select(activeNameGroup).select(".AssignedGroup").append(closeBar);

  // THE BIT THAT MOVES MY BAR INTO THE CORRECT GROUP SO I CAN KEEP SELECTING IT AFTER I'VE CHANGED THE NAME ON IT
  if (activeNameGroupId != "") {
    console.log("actGroupID:" + activeNameGroupId);
    $("[id='"+activeNameGroupId+"']").find(".AssignedGroup").prepend(closeBar);

   d3.select(closeBar).select('.barGroup').attr("y",function(d){
  //   try {
     var groupHeight = d3.select(closeBar.parentNode).attr("height");
     var currY = d3.select(closeBar).select(".barGroup").attr("y");
     console.log("groupHeight:" + groupHeight);
     return d3.min([currY,(groupHeight - BAR_H)]);
//   } catch (ex) {
//     return 0;
//   }
   });

  }
  //  d3.select(closeBar).attr("y", 0);

      console.log("closeBar data ...: ");
      console.log(d3.select(closeBar).data());
      var closeData = d3.select(closeBar).data();
      if(closeData.length > 0) {
      if(closeData[0].hasOwnProperty("UID")) {
        var projectKey = closeData[0].UID;

      var oldName = closeData[0].AssignedToName;
      var uniqueRef = closeData[0].UniqueReference["#text"];
      var ownerName = closeData[0].OwnerName;
      var projTitle = closeData[0].WebName["#text"];



    }
  } // end size closedata
      console.log(closeData);


/*
//TODO:  keep this for future reference
      let tempX = d3.scaleTime()
      .domain(xAxis.scale().domain());  // OF NO USE ??
console.log(xAxis.scale().domain());


console.log(xAxis.scale().range());
*/

//**************************************************//
// *****       this is it                 ***********//
// **************************************************//

var dateFormat = d3.timeFormat("%a %d/%m/%Y");
var scriptDateFormat = d3.timeFormat("%Y,%m,%d");
    //var newX = d3.event.x - deltaX;
        var newX = d3.event.x - thisOffsetX;
     var xPosition = dateFormat(x.invert(newX));
     var scriptDate = scriptDateFormat(x.invert(newX));

//console.log("MondayLock:" + d3.select("#MondayLock").attr("checked"));

if (d3.select("#MondayLock").attr('checked') == 'true') {

        scriptDate = scriptDateFormat(nearestMonday(scriptDate));
        xPosition = dateFormat(new Date(scriptDate));
      //  console.log("locking to MOnday");
}

     console.log("duration:" + duration);
     var newFinish = addBusinessDays(new Date(scriptDate), parseFloat(duration));
     var scriptFinishDate = scriptDateFormat(new Date(newFinish));

     if (d3.select("#FridayLock").attr('checked') == 'true') {

             scriptFinishDate = scriptDateFormat(nearestFriday(scriptFinishDate));
            newFinish = dateFormat(new Date(scriptFinishDate));
     }
/*   var f = new Date(scriptFinishDate); // friday

   f.setDate(f.getDate() + (5 + 7 - f.getDay()) % 7); //assume 5 means it will be Friday

  console.log("friday:" + f) ;
  console.log("newFinish:" + newFinish);
*/

     closeData[0].newStartDate = xPosition;
     closeData[0].newStartDateScript= scriptDate;
     closeData[0].newFinishDate = newFinish;
      closeData[0].newFinishDateScript = scriptFinishDate;

//**************************************************//
// **************************************************//


//  var formattedFinishDate = new Date(convertSPDate(closeData[0].FinishDateExpression["#text"]));

  var formattedFinishDate = newFinish;




//var holidays = [];
var newDuration = calcBusinessDays(new Date(scriptDate), new Date(scriptFinishDate), holidays);

//console.log("formfinishdate:" + formattedFinishDate);
//console.log("new duration:" + newDuration);

  closeData[0].newDuration = newDuration;




  //    console.log("class:" +  d3.select(this).attr("class"));

  //    d3.select(this)
d3.select(closeBar).selectAll(".dateText").remove();

  d3.select(closeBar).select('svg')
      .insert("text")
      .attr('y', 22)
      .attr("font-size", 9)
      .attr("font-family", "sans-serif")
      .attr('width', width)
      .attr("class","dateText")
      .text("new start:" + xPosition);



      d3.select(closeBar).selectAll(".finDateText").remove();
    tempFinText =    d3.select(closeBar).select('svg')
            .insert("text")
            .attr('y', BAR_H)
            .attr("font-size", 9)
            .attr("font-family", "sans-serif")
            .attr('width', width)
            .attr("class","finDateText")
        //    .text("fin:" + newFinish + " / dur:" + newDuration);
          .text("fin:" + formattedFinishDate + " / dur:" + newDuration);

tempFinText.moveToBack();


    console.log("oldname: "+ oldName + "; assigned Name:" + newName);

    try {
    if (newName != "") {

    closeData[0].AssignedToName = newName;



    //  function updateObject(obj, newNameKey, ProjectKey, oldName) {
    // NB:  xPosition = new start date
    symbolAssignees = updateObject(symbolAssignees, newName, projectKey,oldName);
    var newText = uniqueRef + "-" + newName + " (" + ownerName + ")-" + projTitle;
      d3.select(this.parentNode).select("text.barsText")
      .text(newText);
    //  .update();
//  console.log(updateObject(symbolAssignees, newName, projectKey,oldName))
    //console.log(d3.select('.projectBars').datum());


    //circles = allCharts.selectAll('circle.circHandle'); // get them afresh .. don't now if i need to do that
    //    circles.moveToFront();




      }
    } catch (ex) {

      console.log(ex);
      console.log(ex);
      //alert("AssignedToName not found");
    }

    //drawChart();
      //  bars = allCharts.selectAll('rect'); // get them afresh .. don't now if i need to do that
      //   dragHandler(bars);
         barGroups = allCharts.selectAll('.barGroup'); // get them afresh .. don't now if i need to do that
          dragHandler(barGroups);


          nameGroups = allCharts.selectAll('.AssignedGroup'); // get them afresh .. don't now if i need to do that
           dragHandler(nameGroups);

    } // END OF IF NOT dragbottom rect


});


// END OF 'DRAG END'

//dragHandler(bars);
dragHandler(barGroups);
dragHandler(nameGroups);



bars.on("mouseover",  function(d, i) {
//  console.log("mouseover happened");

    var wholeNode = d3.select(this.parentNode);
    var thisBar = d3.select(this);

  });



  bars.on("click",  function(d, i) {
    console.log("click happened");
    /*  return this.each(function() {
         this.parentNode.appendChild(this);
      }); */
      var wholeNode = d3.select(this.parentNode);
      var thisBar = d3.select(this);
      //wholeNode.moveToFront();

    });


/*

    function bdragresize(d) {
      console.log("got here");
      // if (isYChecked) {
         //Max x on the left is x - width
         //Max x on the right is width of screen + (dragbarw/2)
    //     var dragy = Math.max(d.y + (dragbarw/2), Math.min(h, d.y + height + d3.event.dy));
    var thisBar = d3.select(this)
    var parentHeight = d3.select(this.parentNode).attr("height");
    console.log("parentHeight:" + parentHeight);

    console.log(d3.event.y);
  //var dragy = Math.max(d.y, Math.min(h, d.y + height + d3.event.dy));
         //recalculate width
      //   height = dragy - d.y;
  //d3.select(this).attr("y", d3.event.y);
      d3.select(this.parentNode).attr("height", d3.event.y);

         //move the right drag handle
        // dragbarbottom
        //    .attr("y", function(d) { return dragy  });

         //resize the drag rectangle
         //as we are only resizing from the right, the x coordinate does not need to change

    //  }
    }

*/


// for detecting underlying group

    function collide(node) {
      var r = node.radius + 16,
          nx1 = node.x - r,
          nx2 = node.x + r,
          ny1 = node.y - r,
          ny2 = node.y + r;
      return function(quad, x1, y1, x2, y2) {
        if (quad.point && (quad.point !== node)) {
          var x = node.x - quad.point.x,
              y = node.y - quad.point.y,
              l = Math.sqrt(x * x + y * y),
              r = node.radius + quad.point.radius;
          if (l < r) {
            l = (l - r) / l * .5;
            node.x -= x *= l;
            node.y -= y *= l;
            quad.point.x += x;
            quad.point.y += y;
          }
        }
        return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
      };
    }



//    function updateObject(obj, key1, key2, name, UID, val, newVal) {
    function updateObject(obj, newNameKey, ProjectKey, oldName) {
    //    var obj = newVal;
    //var obj=obj;

    console.log("new name:" + newNameKey + "; old name:" + oldName);
  //  var obj = object;

      var tempObj = {};
      var newArray = [];
//TODO: nb also have to update dates
// find the right record, and update the name into a temp obj, delete the object from the data
      $.each(obj,function(i,entry) {
        if(entry.key == oldName) {
      //    console.log("found");
      //   console.log(entry);
      //    console.log(entry.values);
      //     newArray = entry.values;  // why is this not active? do i not need it?
          $.each(newArray, function(k, proj) {
            if (proj.key == ProjectKey) {
              try {
                proj.values[0].AssignedToName = newNameKey;
                tempObj.key = ProjectKey;
                tempObj.values = [proj.values[0]];
                delete proj.values[0];

          //    console.log("found");
            //  console.log(proj.values[0]);
              $.each(obj, function(i, e2){
                  if(e2.key == newNameKey) {
                    newArray.push(tempObj);
                  }
              });
            } catch (ex) {
              console.log("assigntoname not found");
                console.log(proj.value[0]);
                console.log(ex);
              }
            }


          })


          //console.log(entry.name + " : " + entry.value)
   }
});





        return obj;

}


function nearestMonday(date) { //1=Monday //5=Friday

  var m = new Date(date); //work out nearest MOnday // use scroptdate
  //var mday = m.getDay();
  if (m.getDay() == 1) { // MOnday
    // do nothing
  } else
  if (m.getDay() >=6 || m.getDay() == 0) { //if Friday, Saturday or Sunday, next MOnday
     m.setDate(m.getDate() + (1 + 7 - m.getDay()) % 7);
   } else { // tuesday, wednesday, thursday, last monday
     m.setDate(m.getDate() + (1 - m.getDay()) % 7);
   }

  // console.log("returned date:" + m);
   console.log("returned monday:" + m + "; original monday" + new Date(date));

   return m;

}

function nearestFriday(date) { //1=Monday //5=Friday

  var f = new Date(date); //work out nearest MOnday // use scroptdate
  //var mday = m.getDay();
  if (f.getDay() == 5) { // Friday
    // do nothing
  } else
  if (f.getDay() >=2 && f.getDay() <=4) { //if tue, Wed or Thur, next Friday
     f.setDate(f.getDate() + (5 + 7 - f.getDay()) % 7);
   } else { // mon,sat,sun , last friday
    //  f.setDate(f.getDate() - (5 + 7 - f.getDay()) % 7);
     while (f.getDay() != 5){
        f.setDate(f.getDate()-1);
        }
    // f.setDate(f.getDate() + (5 - f.getDay()) % 7);
   }

  // console.log("returned date:" + m);
   console.log("returned friday:" + f + "; original date:" + new Date(date));

   return f;

}




//function getChangedItems(obj, newNameKey, ProjectKey, oldName)
function getChangedItems() {
// obj should always be d3.selectAll("g.GBarGroup") I think - search 'closeData[0]' for some example
    var itemCount = d3.selectAll(".changed").size();

  d3.selectAll("g.GBarGroup").each(function (d,i) {
    if(d.hasOwnProperty("newStartDate") || d.hasOwnProperty("newFinishDate") || d.hasOwnProperty("newCompletion")) {
    console.log(d);
    var webUrl = d.WebHref["#text"];
    var listName = d.ListName["#text"];
//  var listName = "ProjectTaskList";
    var listInternalName = "ProjectTaskList"; //hard to get by code
    var listGuid = d.ListGuid["#text"];
    var itemId = d.ID["#text"];
    var assToName = d.AssignedToName;
    var origAssTo = "";
    try { origAssTo = d.AssignedTo["#text"].split("#")[1]; } catch (ex) {
      // no value3
      console.log(ex);
     };
    console.log("new name:" + assToName + ", oldName:" + origAssTo);
    console.log("webUrl:" + webUrl);







  //  var itemProps = {};
        var url = webUrl;// + "/_api/web/lists/getbytitle('" + listName + "')/items?$filter=ID eq " + itemId + "";
        console.log("url: " + url);


        var itemType =  GetItemTypeForListName(listInternalName);


            var itemProps = {};
            itemProps['__metadata'] = {
  							'type': itemType
  						};

              //var nameProps = {};
            //  itemProps['__metadata'] = {
              //    'type': itemType
              //  };

              var clearPredecessors = false;
              //var userName;

              //var curUserId = _spPageContextInfo.userId;

              var itemDesc = "Updated by "+ currentUser + " via Construction Planner " + new Date();
              itemProps["Body"] = itemDesc;

              //sp format of date: "2018-10-11T15:00:00"
              if(d.hasOwnProperty("newStartDate")) {
                    var updatedStartDate =  new Date(d.newStartDateScript).toISOString().split(".")[0];
                    itemProps["StartDate"] = updatedStartDate;
                    clearPredecessors = true;
              }

              if (d.hasOwnProperty("newFinishDate")) {
                    var updatedFinDate = new Date(d.newFinishDateScript).toISOString().split(".")[0];
                      itemProps["DueDate"] = updatedFinDate;
                      clearPredecessors = true;
              }

              if (d.hasOwnProperty("newDuration")) {
                    var updatedDuration = d.newDuration;
                    itemProps["EstimatedDurationAtCompletion"] = updatedDuration;
                    clearPredecessors = true;
            }

            if (d.hasOwnProperty("newCompletion"))  {
                  var updatedCompletion = d.newCompletion;
                  itemProps["PercentComplete"] = updatedCompletion;
            }

            if (clearPredecessors == true) {
              itemProps["Predecessors"] = {"results":[]};
            }

              console.log("localeCompare names:" + assToName.localeCompare(origAssTo));

              if (assToName.localeCompare(origAssTo) != 0) {
              //  console.log("need to get the new name ID somehow or otherwise update a name - yikes");
                try {

                  if (assToName == "ZZ Not assigned") {
                    itemProps["AssignedToId"] = {"results":[]};
                  } else {
                    if (assToName.startsWith("Gang-"))
                    {
                        itemProps["AssignedToId"] = {"results":[getGroupId(assToName, webUrl)]};
                    } else {
                      itemProps["AssignedToId"] = {"results":[getUserId(assToName, webUrl)]};
                  }


                  }


                    // = [getUserId(assToName, webUrl)];
                  //  console.log("AssignedTo id:" + getUserId(assToName, webUrl));
                  //console.log()
                    updateListItem(url, listName, listGuid, listInternalName, itemId, itemProps, itemCount, "Construction Planner");
                  } catch(ex){
                    //couldn't get a user id somehow, update without it
                    console.log(ex);
                    updateListItem(url, listName, listGuid, listInternalName, itemId, itemProps, itemCount, "Construction Planner");
                  }
              } else {
                //update without getting a user name id
                updateListItem(url, listName, listGuid, listInternalName, itemId, itemProps, itemCount, "Construction Planner");
              }



    //itemProps
    //updateListItem(thisUrl, listName, elementId, thisItem, numItems, calltype);
  }
  });



}


function getUserId(displayName, web){

  //http://tscps/support/_api/web/siteUsers
	var accountName="";

  var requestUri = web +
  "/_api/web/siteusers?$select=*&$filter=Title eq '"+displayName+"'";

  console.log(requestUri);

	//			  "/_api/web/siteusers?$select=LoginName&$filter=Title eq '"+displayName+"'";

	//execute AJAX request
	$.ajax({
		url: requestUri,
		type: "GET",
		headers: { "ACCEPT": "application/json;odata=verbose" },
		async: false,
		success: function (data) {
			if(data.d.results.length>0){
				accountName=data.d.results[0].LoginName.replace("#","%23");
        userId=data.d.results[0].Id;


			}

		},
		error: function () {
			//alert("Failed to get details");
		}
	});
//  console.log('returned userId:' + userId);
	return userId;
}



function getGroupId(displayName, web){

  //http://tscps/support/_api/web/siteUsers
	var accountName="";
//	var requestUri = _spPageContextInfo.webAbsoluteUrl +
//  "/_api/web/siteusers?$select=*&$filter=Title eq '"+displayName+"'";

  var requestUri = web +
  "/_api/web/sitegroups?$select=*&$filter=Title eq '"+displayName+"'";

  console.log(requestUri);

	//			  "/_api/web/siteusers?$select=LoginName&$filter=Title eq '"+displayName+"'";

	//execute AJAX request
	$.ajax({
		url: requestUri,
		type: "GET",
		headers: { "ACCEPT": "application/json;odata=verbose" },
		async: false,
		success: function (data) {
			if(data.d.results.length>0){
			//	accountName=data.d.results[0].LoginName.replace("#","%23");
        groupId=data.d.results[0].Id;

      /*  ensureUser(web, accountName) // doesn't work, think its blocked by IT
        .done(function(data) {
          return userId;
        }) */

//        console.log(userId)
			}

		},
		error: function () {
			//alert("Failed to get details");
		}
	});
//  console.log('returned userId:' + userId);
	return groupId;
}




/*
function ensureUser(webUrl,loginName)
{
   var payload = { 'logonName': loginName };
   return $.ajax({
      url: webUrl + "/_api/web/ensureuser",
      type: "POST",
      contentType: "application/json;odata=verbose",
      data: JSON.stringify(payload),
      headers: {
         "X-RequestDigest": $("#__REQUESTDIGEST").val(),
         "accept": "application/json;odata=verbose"
      }
   });
}
*/
function GetItemTypeForListName(name) {

    var itemType = "SP.Data." + name + "ListItem";

    var encItemType = itemType.replace(/ /g,'_x0020_');
    return encItemType;
}


function updateListItem(webUrl,listName, listGuid, listInternalName, itemID, itemProperties, numitems, calltype)
{
  console.log("itemCount:" + numitems);

      console.log("updateListItem("+webUrl+","+ listName +","+ itemID +","  + itemProperties +","+ numitems +"," + calltype +")");
//  console.log("calltype at updateListItem:" + calltype);
console.log(itemProperties);
  var thisUrl = webUrl;
  var thisId = itemID;
  var thisUrlList = thisUrl + "/Lists/" + listInternalName; //so annoying
  var itemData = JSON.stringify(itemProperties);
  var formFolder = "";

  console.log(JSON.stringify(itemProperties));

  // make a path for document libraries
  if (itemData.indexOf("ListItem") < 0)
  {
    thisUrlList = thisUrl + "/" + listName;
    formFolder = "/Forms";
  }

    $.ajax({
       url: thisUrl + "/_api/web/lists/getbytitle('" + listName + "')/items(" + itemID + ")",
      //  url: thisUrl + "/_api/web/lists('" + listGuid + "')/items(" + itemID + ")",
       type: "POST",
       /*processData: false, */
       contentType: "application/json;odata=verbose",
       data: JSON.stringify(itemProperties),
       headers: {
          "Accept": "application/json;odata=verbose",
          "content-type": "application/json; odata=verbose",
          "X-RequestDigest": $("#__REQUESTDIGEST").val(),
          "X-HTTP-Method": "MERGE",
          "If-Match": "*"

       },
       success: function (err) {
         closeMessage();
         var handler = null;
			//$("#Results").prepend("<div class='updated'><p class='updatedh'>UPDATED <a href='"+thisUrlList+"' target='_blank'>"+thisUrlList+"</a>:</p><div class='updatedb'>"+JSON.stringify(itemProperties)+"</div></div>");


        statusMessage = "<div class='updated'><p class='updatedh'>UPDATED <a href='"+thisUrlList+formFolder +"/DispForm.aspx?ID="+thisId+"' target='_blank'>"+thisUrlList+formFolder+"/DispForm.aspx?ID="+thisId+"</a>:</p><div class='updatedb'>"+
      itemData+"</div></div>" + statusMessage;
      itemCtr++;
      statusHeader = "Updating item " + (itemCtr) + " of " + numItems + " " + itemsDesc;
      if (calltype == "PowerShell") {
        $("#spDlgMirror").append("<div>"+itemData+"<div>");
      }
      if (itemCtr >= numItems) {
        itemsDesc = itemsDesc.toUpperCase();
        //handler = RefreshOnDialogClose; // NOO!!!
        handler = null;
        statusHeader = "*** JOB COMPLETE - PROCESSED " + (itemCtr) + " OF " + numitems + " " + itemsDesc + " *** (" + calltype + ")";
        if (calltype == "PowerShell") {
          //$("#spDlgMirror").html($("#spDlg").html());
            $("#spDlgMirror").append("<div>"+itemData+"<div>");
              $("#spDlgMirror").prepend("<div>"+statusHeader+"<div>");
        }
      }

    //  statusMessage = "<div>*** JOB COMPLETE - PROCESSED " + (itemCtr) + " OF " + numItems + " ITEMS *** </div>" + statusMessage;
            if (calltype != "PowerShell") {
            DismissDlgWithCode(null);
            LaunchMessageDialog(statusHeader,statusMessage, handler);
          }
       },
       error: function (err) {
       		//console.log("failure");
          closeMessage();
       		console.log("AJAX error in request: " + JSON.stringify(err, null, 2));
       		//$("#Results").prepend("<div class='error'>ERROR:<div>"+ JSON.stringify(err, null, 2) +"</div></div>");
          statusMessage = "<div class='error'>ERROR:<div>"+ JSON.stringify(err, null, 2) +"</div></div>"+statusMessage;
          DismissDlgWithCode(null);
          if(calltype != "PowerShell")
          {
          LaunchMessageDialog("Updating progress ...",statusMessage);
          }


           //failure(itemProperties);
         //  failure(data);
       }
    });
}


function ExecuteOnFailure(sender, args) {
  closeMessage();
 alert('Error in Getting List ID');
 }







function updateObjectDates(obj, ProjectKey, newStart, newFinish) {
//    var obj = newVal;
//var obj=obj;

//console.log("new name:" + newNameKey + "; old name:" + oldName);
//  var obj = object;

  var tempObj = {};
  var newArray = [];
//TODO: nb also have to update dates
// find the right record, and update the name into a temp obj, delete the object from the data
  $.each(obj,function(i,entry) {
  //  if(entry.key == oldName) {
    //  console.log("found");
  //   console.log(entry);
  //    console.log(entry.values);
       newArray = entry.values;
      $.each(newArray, function(k, proj) {
        if (proj.key == ProjectKey) {
            proj.values[0].StartDateExpress["#text"] = Date(newStart).toISOString();
            tempObj.key = ProjectKey;
            tempObj.values = [proj.values[0]];
            delete proj.values[0];
            obj[i].values.push(tempObj);
          //console.log("found");
        //  console.log(proj.values[0]);
        //  $.each(obj, function(i, e2){
        //      if(e2.key == newNameKey) {
        //        newArray.push(tempObj);
        //      }
        //  });
        }


    })


      //console.log(entry.name + " : " + entry.value)
//}
});


//console.log(newArray);


  //  console.log(obj);


    return obj;
//}
}






var relBarDim;


  var resizeHandler = d3.drag()
      .on("start", function (d) {

        console.log("resizing");
      //  var current=d3.select(this);

        if (d3.select(this).classed("circHandle") == true) {
          var current=d3.select(this);
          var relatedBar = d3.select(this.parentNode).select('rect');
               relatedBar.classed("changed", true);


            //   var projectKey = closeData[0].UID;
          //     var oldName = closeData[0].AssignedToName;
            //   var uniqueRef = closeData[0].UniqueReference["#text"];
          //     var ownerName = closeData[0].OwnerName;
          //     var projTitle = closeData[0].WebName["#text"];




          var relatedInfoCirc = d3.select(this.ParentNode).select("circle.circInfo");
        //    parentInfoCirc.attr("cx", d3.event.x);
          relBarDim = computeDimensions(relatedBar);
        //  console.log(relatedBar.attr("x"));
          deltaX = relBarDim.x - d3.event.x;
          deltaY = relBarDim.y - d3.event.y;
          deltaCx = current.cx - d3.event.y - height/2;
          deltaW = relBarDim.width;

        //    deltaW = current.cx - related.x;
            //deltaW = current.cx - deltaW;
      //  deltaW = current.attr("width") + d3.event.x - clWidth;

      //  deltaY = current.attr("y") - d3.event.y;

  //  d3.select(this.parentNode.parentNode.appendChild(this.parentNode));

    } // end of if class is circhandle

      })
      // no need, dragging the copy NOW

      .on("drag", function () {

      //  var current=d3.select(this);
//var relatedBar = current.select(this.parentNode).select('rect');
  if (d3.select(this).classed("circHandle") == true) {
  //console.log("deltaW:" + deltaW);
          d3.select(this)
        //  .moveToFront()


              .attr("cx", d3.event.x)

          d3.select(this.parentNode).select("rect")
        //  .moveToFront()
          .attr("width", d3.event.x-relBarDim.x);
          d3.select(this.parentNode).select("circle.circInfo")
         .attr("cx", d3.event.x);
        //  relatedInfoCirc
        // .attr("y", d3.event.y + deltaY + 12);

        // d3.select(this.parentNode).select("circle")
      //   .moveToFront()

      } //end if circlhandle
      })
      .on("end", function(d){
        // find the new bar locations
      //  console.log(d.StartDateExpression['#text'])
    //  console.log(d);
      if (d3.select(this).classed("circHandle") == true) {

  var relatedBar = d3.select(this.parentNode); //.select('rect');
        //  deltaX = relBarDim.x - d3.event.x;

    var closeBar = this.closest("g.GBarGroup");  //WORKS
    console.log("closeBar data ...: ");
 //   console.log(d3.select(closeBar).data());
    var closeData = d3.select(closeBar).data();

    var dateFormat = d3.timeFormat("%a %d/%m/%Y");
    var scriptDateFormat = d3.timeFormat("%Y,%m,%d");

    var newX = parseFloat(d3.select(this).attr("cx")) + parseFloat(d3.select(this.parentNode).attr("x"));  //svg + event //drag circle position

/*
    console.log("class:" + d3.select(this.parentNode).attr("class"));
    console.log("parentX:" + d3.select(this.parentNode).attr("x"));
    console.log("circ cx:" + d3.select(this).attr("cx"));
*/
    console.log(newX);

   var newFinish = dateFormat(x.invert(newX));
   var scriptFinishDate = scriptDateFormat(x.invert(newX));
   //now check for Monday

   if (d3.select("#FridayLock").attr('checked') == 'true') {
           scriptFinishDate = scriptDateFormat(nearestFriday(scriptFinishDate));
           newFinish = dateFormat(new Date(scriptFinishDate));
   }



   closeData[0].newFinishDate = newFinish;
    closeData[0].newFinishDateScript = scriptFinishDate;

    var duration = closeData[0].EstDurationAtCompletion["#text"];
    var newDuration;

    //if (duration = -1


        if (closeData[0].hasOwnProperty("newStartDateScript"))
        {

          console.log("newSDScript:" + new Date(closeData[0].newStartDateScript) +  ", new scriptFinishDate:" + new Date(scriptFinishDate));
          newDuration = calcBusinessDays(new Date(closeData[0].newStartDateScript), new Date(scriptFinishDate), holidays);
        } else {

          console.log("finishdate expression date:" + new Date(parser(convertSPDateOnly(d.StartDateExpression["#text"]))) +  ", new scriptFinishDate:" + new Date(scriptFinishDate));
          newDuration = calcBusinessDays(new Date(parser(convertSPDateOnly(d.StartDateExpression["#text"]))), new Date(scriptFinishDate), holidays);

        }

        console.log("newDuration:" + newDuration);
        closeData[0].newDuration = newDuration;



        d3.select(closeBar).selectAll(".finDateText").remove();
          d3.select(closeBar).select('svg')
              .append("text")
              .attr('y', BAR_H)
              .attr("font-size", 9)
              .attr("font-family", "sans-serif")
              .attr('width', width)
              .attr("class","finDateText")
              .text("fin:" + newFinish + " / dur:" + newDuration);


/*
          d3.select(closeBar).selectAll(".durationText").remove();
            d3.select(closeBar).select('svg')
                .append("text")
            //    .attr('x', d3.select(this).attr('cx')-30)
                .attr('y', 42)
                .attr("font-size", 9)
                .attr("font-family", "sans-serif")
                .attr('width', width)
                .attr("class","durationText")
                .text("duration:" + newDuration);
*/
  //              d3.select(this).moveToFront();
      circles = allCharts.selectAll('circle.circHandle'); // get them afresh .. don't now if i need to do that
      circles.moveToFront();
       resizeHandler(circles);
     } // end of if circHandle = true
      })
      ;


resizeHandler(circles);

      var newStart, newFinish, newDuration, newDurationText;

function infoHover() {
var el = d3.select(this), isEntering = d3.event.type === "mouseenter";
el
  .classed("hovering", isEntering)
  .attr(
    "r",
    isEntering || el.classed("hovering") ?
      HANDLE_R_ACTIVE : HANDLE_R
  );
}


function groupHover() {
var el = d3.select(this), isEntering = d3.event.type === "mouseenter";
el
  .classed("hovering", isEntering)
  .attr(
    "r",
    isEntering || el.classed("hovering") ?
      HANDLE_R_ACTIVE : HANDLE_R
  );
}

function finishHover() {
var el = d3.select(this), isEntering = d3.event.type === "mouseenter";

el
  .classed("hovering", isEntering)
  .attr(
    "width",
    isEntering || el.classed("hovering") ?
      HANDLE_R_ACTIVE : HANDLE_R
  )
  .attr(
    "height",
    isEntering || el.classed("hovering") ?
      HANDLE_R_ACTIVE : HANDLE_R
  );
  d3.event.stopPropagation();
}



  function computeDimensions(selection) {
    var dimensions = null;
    var node = selection.node();

    if (node instanceof SVGElement) { // check if node is svg element
      dimensions = node.getBBox();
    } else { // else is html element
      dimensions = node.getBoundingClientRect();
    }
    //console.log(dimensions);
    return dimensions;
  }



  function resizerHover() {
  var el = d3.select(this), isEntering = d3.event.type === "mouseenter";
  el
    .classed("hovering", isEntering)
    .attr(
      "r",
      isEntering || el.classed("resizing") ?
        HANDLE_R_ACTIVE : HANDLE_R
    );
}



function rectResizeStartEnd() {
    var el = d3.select(this), isStarting = d3.event.type === "start";
    d3.select(this)
      .classed("resizing", isStarting)
      .attr(
        "r",
        isStarting || el.classed("hovering") ?
          HANDLE_R_ACTIVE : HANDLE_R
      );
          //  console.log(getNewData);

      //    mydata=  getNewData();
  }

  function rectResizing(d) {
//console.log(d);
    var dragX = Math.max(
      Math.min(d3.event.x, MAX_TRANSLATE_X),
      MIN_TRANSLATE_X
    );

    var dragY = Math.max(
      Math.min(d3.event.y, MAX_TRANSLATE_Y),
      MIN_TRANSLATE_Y
    );

  /*  if (d3.select(this).classed("topleft")) {

      var newWidth = Math.max(d.width + d.x - dragX, MIN_RECT_WIDTH);

      d.x += d.width - newWidth;
      d.width = newWidth;

      var newHeight = Math.max(d.height + d.y - dragY, MIN_RECT_HEIGHT);

      d.y += d.height - newHeight;
      d.height = newHeight;

    } else { */

      d.width = Math.max(dragX - d.x, MIN_RECT_WIDTH);



    //  d.height = Math.max(dragY - d.y, MIN_RECT_HEIGHT);

  //  }

  //  update();
  }


  function intersectRect(r1, r2) {
      var r1 = r1.getBoundingClientRect();    //BOUNDING BOX OF THE FIRST OBJECT
      var r2 = r2.getBoundingClientRect();    //BOUNDING BOX OF THE SECOND OBJECT

      //CHECK IF THE TWO BOUNDING BOXES OVERLAP
    return !(r2.left > r1.right ||
             r2.right < r1.left ||
             r2.top > r1.bottom ||
             r2.bottom < r1.top);
  }

function intersectRect2(rec1, rec2) {

  //console.log(rec1.class)

var r1, r2;
    if (rec1 instanceof SVGElement) { // check if node is svg element
      r1 = rec1.getBBox();
    } else { // else is html element
        //r1 = r1.getBBox();
      r1 = rec1.getBoundingClientRect();
    }

    if (rec2 instanceof SVGElement) { // check if node is svg element
      r2 = rec2.getBBox();
    } else { // else is html element
      r2 = rec2.getBoundingClientRect();
    }

    //  var r1 = r1.getBoundingClientRect();    //BOUNDING BOX OF THE FIRST OBJECT
    //  var r2 = r2.getBoundingClientRect();    //BOUNDING BOX OF THE SECOND OBJECT

      //CHECK IF THE TWO BOUNDING BOXES OVERLAP
    return !(r2.left > r1.right ||
             r2.right < r1.left ||
             r2.top > r1.bottom ||
             r2.bottom < r1.top);
  }

    function computeDimIntersect(selection1, selection2) {
      var r1 = null;
      var r2 = null;
      var node1 = selection1; //.node();
      var node2 = selection2; //.node();

      if (node1 instanceof SVGElement) { // check if node is svg element
        r1 = node1.getBBox();
      } else { // else is html element
        r1 = node1.getBoundingClientRect();
      }

      if (node2 instanceof SVGElement) { // check if node is svg element
        r2 = node2.getBBox();
      } else { // else is html element
        r2 = node2.getBoundingClientRect();
      }
      //console.log(dimensions);
    //  return dimensions;
    //}

    //  var r1 = r1.getBoundingClientRect();    //BOUNDING BOX OF THE FIRST OBJECT
    //  var r2 = r2.getBoundingClientRect();    //BOUNDING BOX OF THE SECOND OBJECT

      //CHECK IF THE TWO BOUNDING BOXES OVERLAP
    return !(r2.left > r1.right ||
             r2.right < r1.left ||
             r2.top > r1.bottom ||
             r2.bottom < r1.top);
  }

  function intersectFutureRect(r1, r2, width) {
      var r1 = r1.getBoundingClientRect();    //BOUNDING BOX OF THE FIRST OBJECT
      var r2 = r2.getBoundingClientRect();    //BOUNDING BOX OF THE SECOND OBJECT

      //CHECK IF THE TWO BOUNDING BOXES OVERLAP
    return !(r2.left > r1.right ||
             r2.right < r1.left ||
             r2.top > r1.bottom ||
             r2.bottom < r1.top);
  }



// HERE'S THE 'TODAY' LINE

  var today = new Date();
  var xNow = x(today);
    allCharts.append("line").attr("class","today").attr("x1", xNow) //<<== change your code here
//  d3.select('.chart').append("line").attr("class","today").attr("x1", xNow) //<<== change your code here
    .attr("y1", 0).attr("x2", xNow) //<<== and here
/*    .attr("y2", bBoxHeight) */
    .attr("y2", function(d) {
      console.log('y2 height:' + d3.select(this.parentNode).attr('class'));
      return d3.select(this.parentNode).attr('height');
    })

    .style("stroke-width", 2)
    .style("stroke", "red")
    .style("fill", "none");
  //    .attr("y2", height).style("stroke-width", 2).style("stroke", "red").style("fill", "none");
  //add table of details
//  d3.select('#tableplaceholder').text("");
//}



//bars.on("dblclick",function(d){ alert("node was double clicked"); });

//bars.on("click",function(d){ alert("node was SINGLE clicked"); });




//dragHandler(svg.selectAll("use"));




// SETTING UP THE ZOOM - DO THIS 'AFTER ALL OTHER CLICK EVENTS'

//   const catchAll = d3.select('.chart') //changed to var so that the 'reopen in chrome' msg would work in IE *sighs*
   var catchAll = d3.select('.chart')

    .append('svg')
    .attr('id','zoomOverlay')
      .attr('class', 'zoom')
    .append('rect')
      .attr('fill', 'none')
//        .attr('width', width)
      .attr('width', '100%')
    //  .attr('height', wrapper.getBoundingClientRect().bottom);
    .attr('height', bBoxHeight)
//    .attr("transform-origin", "0,20,-50")

    ;


  // --- add tooltip
//  var tooltip = d3.select(wrapper).insert('div',':first-child')
/* var tooltip = d3.select(wrapper).append('div')
            .attr('class', 'tooltip'); */


//see  http://jsfiddle.net/armensg/8Agje/3/

var panMeasure = 0;
var oldScale = 1;

var zoomable = true;


function getTranslation(transform) {
  // Create a dummy g for calculation purposes only. This will never
  // be appended to the DOM and will be discarded once this function
  // returns.
  var g = document.createElementNS("http://www.w3.org/2000/svg", "g");

  // Set the transform attribute to the provided string value.
  g.setAttributeNS(null, "transform", transform);

  // consolidate the SVGTransformList containing all transformations
  // to a single SVGTransform of type SVG_TRANSFORM_MATRIX and get
  // its SVGMatrix.
  var matrix = g.transform.baseVal.consolidate().matrix;

  // As per definition values e and f are the ones for the translation.
  return [matrix.e, matrix.f];
}

//  var zoom = d3.zoom()//.on('zoom', zoomed);
//var savedTransformEvent;

var catchAllZoom =   catchAll.call(d3.zoom()
//var catchAllZoom =   catchAll.call(zoom
//   .scaleExtent([0.05, 20])
        .scaleExtent([0.5, 4])
//   .translateExtent([[-20,-20], [width, Infinity]])
   .translateExtent([[-100,-100], [width*2, Infinity]])
    .on("start", function() {

        const { transform } = d3.event;
      console.log("zoom started");

    })
    .on("end", function() {
      const { transform } = d3.event;
      console.log("zoom ended");
    /*  d3.select('.axisWeekFloating').select('line')
      .attr("y2", function(d) {

  parentY = -parentBox.y;
        thisY2 = d3.select(this).attr("y2") - parentY;
      return thisY2;
    }); */
    //  );
    /*  allCharts.selectAll(".GBarGroup")
      .attr('x', d => transform.applyX(spanX(d))) */
  //    .attr('x', d => spanX(d)+20)
    })
    .on("zoom", function() {
      if (zoomable == true)
      {
        console.log("zooming")
        const { transform } = d3.event;

        zoomChart(transform);



} // end of zoomable true
    //    var today = new Date();

          //style("stroke-width", 2).style("stroke", "red").style("fill", "none");




  }));

  var parentBox;
var tempTrans = [0, 0];
function zoomChart(transform) {
  tempTrans = getTranslation(transform);


      d3.select('.chart').selectAll('g')
        /*  .attr("transform-origin", "0,20,-50") */
      //.attr("transform", function(d) {
      //return "translate(" + tempTrans + ")scale(" + transform.applyX(x(d)) + ")")};
      .attr("transform", "translate(" + tempTrans + ")scale(" + transform.k + ")");

  /*    d3.select('.chart').selectAll('svg.AssignedGroup')
      //.attr("transform", function(d) {
      //return "translate(" + tempTrans + ")scale(" + transform.applyX(x(d)) + ")")};
      .attr("transform", "translate(" + tempTrans + ")scale(" + transform.k + ")")
      .attr("height", function (d) {
                //    var gpHeight = d.height;
           return d.values.length*25;
       });
*/



      xNow = x(today);
    //  yNow = y(today);
  //    allCharts.select("line.today")
    d3.selectAll("line.today")
      .attr("x1", transform.applyX(xNow))
      .attr("x2", transform.applyX(xNow))
      .attr("y2", function(d) {
          return d3.select(this.parentNode).attr('height');
      });
    //  .attr("y1", transform.applyY(yNow))
  //  .attr("y2", transform.applyY(yNow));


       parentBox = wrapper.getBoundingClientRect();
//var barGroupHeight = computeDimensions(d3.select("barGroup")[0]); //only need 1, the first one

//  d3.selectAll(".AssignedGroup").each(function(d) {
  d3.selectAll(".labelText").each(function(d) {
  //box =  d3.select(this + "> text.labelText").getBoundingClientRect();
      //box = this.getBBox();
        box = this.getBoundingClientRect();

      //  console.log(box);
        newY = parentBox.y - box.y;
        var groupBox = d3.select(this.parentNode.parentNode);
      //  var
      //  var groupBoxGroup = d3.select(this.parentNode.parentNode.ParentNode);
      //groupBoxSize = computeDimensions(groupBox);
    //    console.log(groupBoxGroup.attr("class"));
      //  var groupBoxHeight = groupBox.height;
      //  console.log(group)
      //  console.log(d3.select(this.parentNode.parentNode).attr("class"));
      //   groupBox.attr("transform", "translate(" + tempTrans + ")scale(" + transform.k + ")");
         groupBox.attr("height", function(d) {
      //   console.log(groupBox.attr("data-length"));

          return parseInt(groupBox.attr("data-length"))*BAR_H  *transform.k;
          //  return parseInt(groupBox.attr("height"))  *transform.k;
         })
         groupBox.attr("y", function(d) {
    //     console.log(groupBox.attr("data-length"));
          return parseInt(groupBox.attr("data-length")-1)*BAR_H;
        //  return parseInt(groupBox.attr("height")-1)*transform.k;
         })
      }


    );



oldScale = transform.k;


wrapper = document.querySelector('.chart');
infowrapper = document.querySelector('#info');
//wrapper2 = computeDimensions(d3.selectAll('svg'));
//wrapperDim = d3.select(".chart").getBoundingClientRect();
//console.log(wrapperDim);
//console.log(wrapper);
clHeight = wrapper.clientHeight;
//var chartHeight = $(".chart").height();
wrapperDetails = wrapper.getBoundingClientRect();
infoDetails = infowrapper.getBoundingClientRect();
bBoxHeight = wrapperDetails.height;
bBoxTop = wrapperDetails.top;//-infoDetails.top;


xAxisWeekFloating.tickSize((bBoxHeight-infoDetails.height));
xAxisWeekFloating3.tickSize((bBoxHeight-infoDetails.height+20));


    globalX.call(xAxis.scale(transform.rescaleX(x)));
    globalXWeek.call(xAxisWeek.scale(transform.rescaleX(x)));
  //globalXWeekFloating2.call(xAxisWeekFloating2.scale(transform.rescaleX(x)));
      globalXWeekFloating3.call(xAxisWeekFloating3.scale(transform.rescaleX(x)));
    globalXWeekFloating.call(xAxisWeekFloating.scale(transform.rescaleX(x)));

xAxis.scale(transform.rescaleX(x));


var visibleDomain = (xAxis.scale().domain());
console.log(visibleDomain);
//shift name textlabels  along ...
d3.selectAll(".labelText").attr("x", d => x(visibleDomain[0]));



}


// ZOOMING ISN'T WORKING PROPERLY
// LOOK AT THIS:  https://bl.ocks.org/SevenChan07/3fbb45be891cc3fda3bf139e4853535b
d3.select("#UnlockZoomBtn").on("click", function() {

d3.event.stopPropagation();
  //alert("button clicked");
// nb don't have to worry about true/false cos button is unclickable, under zoom box, when unlocked
  d3.select("#UnlockZoomBtn").attr("value", "Lock Zoom/Pan").attr("locked","false");

  /*$("#instructions").text("Use scrollwheel to zoom width, hold click and drag to pan. Click the Zoom/Pan button to lock/unlock the viewport."); */


  zoomable=true;
  d3.select('#zoomOverlay').classed('zoom', true);
    d3.select('#zoomOverlay').classed('hidden', false);
  catchAllZoom =   catchAll.call(d3.zoom()
      .scaleExtent([0.05, 20])
      .on("zoom", function() {
        const { transform } = d3.event;

    zoomChart(transform);


      //    var today = new Date();

            //style("stroke-width", 2).style("stroke", "red").style("fill", "none");


    }));

});


d3.select('#updateChangedItemsBtn').on("click", function() {

  var changedCount = d3.selectAll(".changed").size();
  var itemCountText = "There are " + changedCount + " changed items.";
  if (changedCount  == 1 ) { itemCountText = "There is 1 changed item."};

  var resp = confirm("Click OK to update changed task items in BrightWork.  Only tasks on projects you have authority to update will be changed.\n\n "+itemCountText+"\n\nChanged Items are marked with a red border.");

  if (resp == 1) {

    getChangedItems();
  } else {
    console.log("nothing changed");
  }
});


d3.select("#trainingProjects").on("click", function(){
  console.log('traning projects clicked');
  console.log(d3.select("#trainingProjects").attr('checked'));
  if (d3.select("#trainingProjects").attr('checked') != true) {
    console.log("training projects: no")
    trainingProjects = false;
    d3.select('.chart').selectAll('*').remove();
  //  d3.selectAll(".Axis").remove();
    initSomething();
  }
});


d3.select('#clearOldBtn').on("click", function() {

//  var changedCount = d3.selectAll(".changed").size();
//  var itemCountText = "There are " + changedCount + " changed items.";
//  if (changedCount  == 1 ) { itemCountText = "There is 1 changed item."};

  var resp = confirm("Click Ok to remove all items with a finish date prior to 'today' from this planner (does not affect the original BrightWork tasks in any way).  "+
  "\n\nAlternatively, to ensure completed work is not displayed in future, mark the task as 'complete' and click 'Update Changed Items'.  \n\n"+
  "To use updated data immediately, open and save the data report and save the data report as described on the instructions page.  Then click F5 refresh on this page to show the updated data.");

  if (resp == 1) {

    clearOldItems();

  //  getChangedItems();
  } else {
    console.log("nothing changed");
  }
});

//var removeArr = [];

function getGangList(btnEvent) {
  var requestUri = "/_api/web/SiteGroups";
  var gangArr = [];
          $.ajax({
              url: requestUri,
              type: "GET",
              headers: { "ACCEPT": "application/json;odata=verbose" },
              success: function (data) {
                  $.each(data.d.results, function (i, item){
                      var title = item.Title;
                    //  console.log(title);
                      if(title.startsWith("Gang-")) {
                        gangArr.push(title);
                      }
                    //  var currentItemID = item.ID;

                      // Check Work packages item
                  //    alert("Item Nr: " + currentItemID + "Title: " + title);
                  })
                  updateResourcesBtnClickContinued(btnEvent, gangArr);
              },
              error: function () {
                  console.log("Error getting items");
              }
          });
}




//var newName;

d3.select('#updateResourcesBtn').on("click", function() {
  newName = "";
activeNameGroupId = "";
//IteratethroughGroup();
getGangList(this);

//console.log(gangList);


}); //end on click

var newItemCtr = -1;

function updateResourcesBtnClickContinued(bntEvent, gangArr) {
  var dlgText = "";



  d3.selectAll(".labelText").classed("darker", false);
  //  d3.select(".AssignedGroup").attr("pointer-events",null); //restore pointer events

        d3.selectAll('g.assignedGroupGp').each(function(d,i) {
          dlgText += "<input type='checkbox' class='resourceCheckbox' name='remResource' resource='"+d.key+"' id='"+d.key.replace(/\s/g, '')+" checked='false' onclick='javascript:alterResourceStatus(this)'/>  "+d.key +"<br />";

        });
        dlgText = //"<div><span class='boxPrompt'>Deactivate All</span><input box id='deactivateNamesChk' type='checkbox' checked='false' /></div>" +
        "<div><span class='boxPrompt'>Check names to remove from the Planner:</span></div>" + dlgText;
        dlgText = dlgText + "<span class='boxPrompt'>Add a name: </span><input box id='newResource' placeholder='A Full Username known to SP' size='30' onchange='javascript:addResource(this)' />";
        dlgText = dlgText += "<div><span class='gangList boxPrompt'>Gang names available:</span><ul class='gangList'><li> " + gangArr.join('</li><li>') +"</li></ul></div>";
        LaunchConfirmDialog("Update Resources",dlgText, function(result){
             if (result == true) {
                //deal with new person
                console.log("newName:" + newName);
            if(deactivateNames == true)  {
              d3.selectAll(".labelText").classed("darker", false);

            }
            if(newName != "") {
            //  d3.select("g.assignedGroupGp")  // 1 only??
            newId = "assignedto-"+newName;

  // BEGINNING OF CREATION
  symbolAssignees.push({key: newName, values:[]});

  groupCtr = symbolAssignees.length-1;

//  console.log(symbolAssignees[groupCtr]);
//  console.log(symbolAssignees);


        var newSection = d3.select(wrapper)
      //  allCharts
          .insert('g', ":first-child")
          .attr('class', 'assignedGroupGp new')
          .attr('id', newId)
          .datum(symbolAssignees[groupCtr])
          .enter();

          d3.select('.new').append('svg')
          .attr('height', BAR_H)
          .attr('class','AssignedGroup')

          .attr('assignedName', newName)
        //  .append('rect')
          .attr('height', BAR_H)
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', '100%')
        /*  .attr('background-color', function(d,i) {

          return d3.rgb(colorScaleNewSection(i))
        } ) */
          .attr('style', function(d,i) {
            console.log(d3.rgb(colorScaleNewSection(i)));
            newItemCtr++;
          return 'background-color: '  + d3.rgb(colorScaleNewSection(newItemCtr));
        })
          .attr('opacity', '0.7')
          .attr('data-length',1)
          .call(dragHandler)
        //  .call()


          ;

console.log(tempTrans);

          var today = new Date();
          var xNow = x(today)*oldScale+tempTrans[0];
        //  console.log("newSection classs:" +newSection.attr("class"));
            d3.select('.new').select('.AssignedGroup').append("line").attr("class","today")
            .attr("x1", xNow) //<<== change your code here
          //  d3.select('.chart').append("line").attr("class","today").attr("x1", xNow) //<<== change your code here
            .attr("y1", 0)
            .attr("x2", xNow) //<<== and here
            .attr("y2", function(d) {
    //       console.log('y2 height:' + d3.select(this).attr('class'));
            //  return d3.select('.new').select('.AssignedGroup').attr('height');
                return d3.select(this.parentNode).attr('height');
            })

            .style("stroke-width", 2)
            .style("stroke", "red")
            .style("fill", "none");
//newSection.append


      var newLabel =  d3.select('[assignedName="'+newName+'"]')
        .append('g')
        .attr("class", "labelGroup")
        .append('text')
        .text(newName)
        .attr('class','labelText')
        .attr('width', '100')
        .attr("y", 20)
        .attr("font-size", 20)
        .attr("font-family", "sans-serif")
          .attr("font-weight", "bold")
          .attr('fill', 'silver')
          .attr('opacity', '0.9');

          newLabel.append('line')
            .attr("class","divider")
            .attr("x1", x(minX))
            .attr("x2", x(maxX))
            .attr("stroke", "silver")
            .attr("stroke-width", 1)
              .attr("opacity", 0.5);
          //    .call();

              //above line not showing, why??
        //  newGroup = newSection.select('.AssignedGroup'); // get them afresh .. don't now if i need to do that
        //   dragHandler(newGroup);


      calculateAndApplyHeight(BAR_H);

  //newSection.each(label(null));

    //newSection.moveToFront();
    //.attr('rect')
  //  .attr('x' 0)
  //  .attr('y', 0)
  //  .attr('height', 100)
  // .attr('fill', 'green') //;
  //  .attr('width' '100')
  //  .attr('height', '100')
  //  .attr('fill', 'green');

  // END OF CREATION

            };

var dataLength = 0;
            /// deal with removals
            d3.selectAll("g.assignedGroupGp")
               .each(function(d,i){
              //   console.log(d3.select(this).attr('class'));
                 if (d3.select(this).classed("Remove")){
                  // console.log(d3.select(this));
                   console.log(d.key);
                    dataLength = dataLength + parseInt(d3.select(this).select(".AssignedGroup").attr("data-length"));
                   d3.select(this).remove();
                 }

               }); // end each
            // }; //end if classed
        if (dataLength > 0) {

          /*

          xAxisWeekFloating.tickSize(xAxisWeekFloating.tickSize()-(dataLength+1)*height);
          xAxisWeekFloating3.tickSize(xAxisWeekFloating3.tickSize()-(dataLength+1)*height);

          globalXWeekFloating3.call(xAxisWeekFloating3);
          globalXWeekFloating.call(xAxisWeekFloating);
*/
          calculateAndApplyHeight();

        }


             } //end if result
           }); //end launchconfirm
}


function clearOldItems() {
//  var beforeTodayDomain = ([minX]);
  d3.selectAll("g.GBarGroup").each(function(d) {
    var finishDate;
    var today = new Date();
    if(d.hasOwnProperty("newFinishDateScript")) {
      finishDate = new Date(d.newFinishDateScript);
    } else {
      finishDate = new Date(parser(convertSPDateOnly(d.FinishDateExpression["#text"])));
    }

    if (finishDate < today)
    {
      d3.select(this).remove();
    }
  });
  //reset heights
  d3.selectAll("g.assignedGroupGp").each(function() {
    console.log("num items for:" + d3.select(this).attr("id") + ":- " + d3.select(this).selectAll(".GBarGroup").size());
    var numItems = d3.select(this).selectAll(".GBarGroup").size();
    d3.select(this).select(".AssignedGroup").attr("data-length",numItems);
    if (numItems == 0) { numItems = 1; };
  //  barCtr = -1;
    d3.select(this).selectAll(".barGroup")
    .attr('y', function(d, i) {
      //      barCtr++;
      //if (barCtr > 0)
    //  {
        return i*BAR_H;
    //  } else {
      //  return 0;
    //  }

    })
    var newHeight = height*numItems*oldScale;
    d3.select(this).select(".AssignedGroup").attr("height", newHeight );

  });
  calculateAndApplyHeight();
}

deactivateNames = false;

d3.select("#deactivateNamesChk").on("click", function(){
//  d3.selectAll(".labelText").classed("darker", false);
  deactivateNames = true;
})


d3.select("#collisionBtn").on("click", function(){
  console.log("hit it");
var previousObj;
  var newHeight = BAR_H;
  var newY = 0;
  var hitadjusted = false;
  var testCtr = -1;
var testName = 'Gang-Day';
  var size = d3.select("[assignedName='"+testName+"']").selectAll(".barGroup").size();
d3.select("[assignedName='"+testName+"']").selectAll(".barGroup")
.each(function(d, i) {
  testCtr = -1;
  d3.select(this).attr("y", 0);
//  console.log(d);
  mainObj = d3.select(this);
console.log('size b4 main:' + size);
console.log(mainObj.attr("y"));
//  var size = d.length;

//console.log(collisionDetection(d3.select(this).select('.bars')), i);

    var k=0;
      if (i >0){
        console.log(previousObj.attr("y"));
      while (k < size) {
        k++;
        console.log("hittest:" + collisionDetection(mainObj, i));
        //if (hitTest(mainObj, previousObj))
        if (collisionDetection(mainObj, i))
        {
        //testCtr++;
          newY= newY+BAR_H;
//          newHeight = d3.max([newHeight,newY+BAR_H]);
          newHeight = d3.max([newHeight,newY+BAR_H]);
          mainObj.attr("y", newY);
        //  mainObj = d3.select(this);
      //  testCtr = 0;
      //  break;
      }

      }
        newY = 0;
        testCtr = 0;
      newHeight = d3.max([newHeight,newY+BAR_H]);


      } //end if i !=j
    //} //end while hittest


previousObj = mainObj;




})

d3.select("[assignedName='"+testName+"']").attr("height",newHeight);
console.log("finished");
});


d3.select('#getDataBtn').on("click", function() {

//  var changedCount = d3.selectAll(".changed").size();
//  var itemCountText = "There are " + changedCount + " changed items.";
//  if (changedCount  == 1 ) { itemCountText = "There is 1 changed item."};
//var newData = getNewData();
//console.log(newData);
console.log(d3.selectAll('g.assignedGroupGp').data());
//var myData = JSON.stringify(d3.selectAll('g.assignedGroupGp').data());
var myData = d3.selectAll('g.assignedGroupGp').data();
myData.forEach(function(group,i){
  var projects = group.values;
  projects.forEach(function(project, k) {
  delete  myData[i].values[k].values[0]["#text"];
  })
});
//var newTab = window.open('');
//newTab.write("<div>"+myData +"</div>")

LaunchMessageDialog("Data",JSONstringify(myData));
//LaunchMessageDialog("Data",JSON.stringify(myData, null, '\t'));

});


function JSONstringify(json) {
    if (typeof json != 'string') {
        json = JSON.stringify(json, undefined, '');
    }

    var
        arr = [],
  /*      _string = 'color:green',
        _number = 'color:darkorange',
        _boolean = 'color:blue',
        _null = 'color:magenta',
        _key = 'color:red'; */

        _string = 'blue',
        _number = 'orange',
        _boolean = 'green',
        _null = 'magenta',
        _key = 'red';

    json = json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
        var style = _number;
        if (/^"/.test(match)) {
            if (/:$/.test(match)) {
                style = _key;
            } else {
                style = _string;
            }
        } else if (/true|false/.test(match)) {
            style = _boolean;
        } else if (/null/.test(match)) {
            style = _null;
        }
      //  arr.push(style);
      //  arr.push('');
      //  if (match == '"key":') {
      //  return '<br /><span class='+style +">" + match + '</span>';

    //  } else {
        return '<span class='+style +">" + match + '</span>';
    //  }
        //return match;
    });

    arr.unshift(json);

  //  console.log.apply(console, arr);
    return(arr.toString(""));
}

/*
d3.select('#instructions').on("click", function() {
  alert("coming soon");
}) */

  catchAllZoom.on("click", function() {
  //  alert("clicked");
  //  alert('zoom clicked')
  console.log("catchall clicked, class:"+d3.select(this).attr("class"));
  d3.event.stopPropagation();
  if(zoomable == true) {

    var r = confirm("Lock zoom and pan here?");
      if (r == true) {
      //  this.call(catchAllNoZoom);
    //  catchAllZoom =  catchAll.call(d3.zoom().on("zoom", null));



      //  disableZoom();

    //  d3.select('.chart svg')
    //catchAll.attr("display", "none");
              zoomable = false;
      d3.selectAll('#zoomOverlay').classed('zoom', false)
          d3.selectAll('#zoomOverlay').classed('hidden', true)
      .attr("pointer-events", "false");

      d3.select("#UnlockZoomBtn").attr("value", "Unlock Zoom/Pan").attr("locked","true");
      //$("#instructions").text("Drag bars, use the lower pink circle to resize, the upper circle to view information");


  /*    catchAllZoom =  catchAll.on("zoom", null); */



    } else {
      // do nothing
    }
  } else {
    // zoomable not true
  //  alert("zoomable not true");
  }
    //disableZoom();
  })





/* add a button to rezooom things */




//************************************
// BROWSER DETECTION

function get_browser() {
    var ua=navigator.userAgent,tem,M=ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    if(/trident/i.test(M[1])){
        tem=/\brv[ :]+(\d+)/g.exec(ua) || [];
        return {name:'IE',version:(tem[1]||'')};
        }
    if(M[1]==='Chrome'){
        tem=ua.match(/\bOPR|Edge\/(\d+)/)
        if(tem!=null)   {return {name:'Opera', version:tem[1]};}
        }
    M=M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, '-?'];
    if((tem=ua.match(/version\/(\d+)/i))!=null) {M.splice(1,1,tem[1]);}
    return {
      name: M[0],
      version: M[1]
    };
 }

//*************************************************
// STUFF TO TRY AND GET THE UNDERLYING group (selecting lower SVG objects)

//https://medium.com/@jstubblefield7939/collision-detection-in-d3-js-502fb01290ed
var collisionCount;
var colliding = false;
var collisionDetection = function(bar, i) {
  console.log('col detect:');
  console.log(bar);
//  var radius = 1;
    var radius = BAR_H;
  var collision = false;
  //var hero = bar;
  d3.selectAll(".barGroup").each(function(d, k) {
    if (i !== k) {
    var groupX = d3.select(this).x;
    var groupY = d3.select(this).y;
    var groupW = d3.select(this).width;
    var barX = bar.x;
    var barY = bar.y;
    var barW = bar.width;
/*
    console.log(this.x);
    console.log("gpx:" + groupX + "; gpy:" + groupY + "; gpW:" + groupW);
    console.log("barx:" + barX + "; barY:" + barY);
    */
  //  var barW =
    var a = barX - groupX;
    var b = barY - groupY;
    var c = Math.sqrt(a * a + b * b);
  //  var distance = c;
    var distance = radius;
    if (distance < radius) {

      collision = true;
      console.log("collision:" + this);
      return this;
    }
    } // end if i!=k;
  }); // end enemies.each

  if (collision && collision !== colliding) {
    collisionCount++;
  }
  colliding = collision;
  return colliding;
}; // end collisionDetection







hitTest = function(o, l){
    function getOffset(o){
        for(var r = {l: o.offsetLeft, t: o.offsetTop, r: o.offsetWidth, b: o.offsetHeight};
            o = o.offsetParent; r.l += o.offsetLeft, r.t += o.offsetTop);
        return r.r += r.l, r.b += r.t, r;
    }
    var a = arguments, j = a.length;
    j > 2 && (o = {offsetLeft: o, offsetTop: l, offsetWidth: j == 5 ? a[2] : 0,
    offsetHeight: j == 5 ? a[3] : 0, offsetParent: null}, l = a[j - 1]);
    for(var b, s, r = [], a = getOffset(o), j = isNaN(l.length), i = (j ? l = [l] : l).length; i;
        b = getOffset(l[--i]), (a.l == b.l || (a.l > b.l ? a.l <= b.r : b.l <= a.r))
        && (a.t == b.t || (a.t > b.t ? a.t <= b.b : b.t <= a.b)) && (r[r.length] = l[i]));
    return j ? !!r.length : r;
};



//**********************************************************






} // end d3 inclusions

d3.selection.prototype.moveToFront = function() {
    return this.each(function() {
       this.parentNode.appendChild(this);
    });
   };

   d3.selection.prototype.moveToBack = function() {
       return this.each(function() {
         const firstChild = this.parentNode.firstChild;
         if(firstChild) {
          this.parentNode.insertBefore(this, firstChild);
        }
       });
      };



Date.prototype.getWeekNumber = function(weekstart) {
  var target = new Date(this.valueOf());

  // Set default for weekstart and clamp to useful range
  if (weekstart === undefined) weekstart = 1;
  weekstart %= 7;

  // Replaced offset of (6) with (7 - weekstart)
  var dayNr = (this.getDay() + 7 - weekstart) % 7;
  target.setDate(target.getDate() - dayNr + 3);

  var firstThursday = target.valueOf();

  target.setMonth(0, 1);
  if (target.getDay() !== 4) {
      target.setMonth(0, 1 + ((4 - target.getDay()) + 7) % 7);
  }

  return 1 + Math.ceil((firstThursday - target) / 604800000);
};

Date.prototype.getFiscalWeekNumber = function(weekstart) {
  var target = new Date(this.valueOf());

  // Set default for weekstart and clamp to useful range
  if (weekstart === undefined) weekstart = 1;
  weekstart %= 7;

  // Replaced offset of (6) with (7 - weekstart)
  var dayNr = (this.getDay() + 7 - weekstart) % 7;
  var halfYear = 182; // days
  if (dayNr > halfYear) {
    dayNr = dayNr-halfYear;
  } else {
    dayNr = dayNr+halfYear;
  }
  target.setDate(target.getDate() - dayNr + 3);



  var firstThursday = target.valueOf();

  target.setMonth(0, 1);
  if (target.getDay() !== 4) {
      target.setMonth(0, 1 + ((4 - target.getDay()) + 7) % 7);
  }

  return 1 + Math.ceil((firstThursday - target) / 604800000);
};



//from this stackexchange question: http://stackoverflow.com/questions/1890203/unique-for-arrays-in-javascript
function checkUnique(arr) {
    var hash = {}, result = [];
    for ( var i = 0, l = arr.length; i < l; ++i ) {
        if ( !hash.hasOwnProperty(arr[i]) ) { //it works with objects! in FF, at least
            hash[ arr[i] ] = true;
            result.push(arr[i]);
        }
    }
    return result;
}







function getAllData() {
  d3.selectAll('chart')
}




function getNewData() {

  // DID NOT END UP BEING NEEDED .DATA() IS GOOD ENOUGH OMG
// var nodes = $.extend(true, [], d3.selectAll('g.node'));

 //var closeBar = this.closest("g.GBarGroup");  //WORKS
// console.log("closeBar data ...: ");
//   var closeData = d3.select(closeBar).data();
//var nodes = $.extend(true, [], d3.selectAll('g.GBarGroup'));
var nodes = $.extend(true, [], d3.selectAll('g.assignedGroupGp'));
//console.log(nodes);
//  var nodes = $.extend(true, [], chart);
// var nodes = $.extend(true, [], allCharts);
//  var nodes = $.extend(true, [], d3.selectAll('.chart.node'));
 // Only need the 'root' nodes at depth 0, because it has all the children
 //   associated with it. Just strip out the unneeded metadata...

var groupNodes = nodes._groups[0];

 nodes.each( function() {
     var node_data = d3.select(this).datum();
  //   console.log(node_data);
     if (node_data.depth == 0) {
         var children = node_data.children;
         if (children != null) {
             $.each(children, function(index, child) {
                 remove_d3_metadata(child);
             });
         }
     }
 });

// root_node = nodes[0][0].__data__;
//  return nodes[0][0].__data__;
//console.log(nodes.__data__);
//console.log("got data");
//  console.log(d3.selectAll('.AssignedGroup'));
//console.log(nodes);
//console.log(nodes._groups[0]);
//  return nodes[0][0].__data__;
  return nodes._groups[0];

  //  console.log(nodes._groups)//.__data__);
  //     return nodes._groups; //.__data__;
}



var remove_d3_metadata = function(node_data) {
    // remove the d3 metadata
    console.log(node_data);

    delete node_data.parent;
    delete node_data.x;
    delete node_data.x0;
    delete node_data.y;
    delete node_data.y0;
    delete node_data.__proto__;

    var grandchildren = node_data.children;
    if (grandchildren != null) {
        $.each( grandchildren, function(index, grandchild) {
            remove_d3_metadata(grandchild);
        });
    }
};

function addBusinessDays(d,n) {
    d = new Date(d.getTime());
    var day = d.getDay();
    d.setDate(d.getDate() + n + (day === 6 ? 2 : +!day) + (Math.floor((n - 1 + (day % 6 || 1)) / 5) * 2));
    return d;
}


function calcBusinessDays(dDate1, dDate2, holidays) { // input given as Date objects
    //console.log("dDate1:" + dDate1 + ", dDate2:" + dDate2);
    var iWeeks, iDateDiff, iAdjust = 0, i;
    if (dDate2 < dDate1) return -1; // error code if dates transposed
    var iWeekday1 = dDate1.getDay(); // day of week
    var iWeekday2 = dDate2.getDay();
    iWeekday1 = (iWeekday1 == 0) ? 7 : iWeekday1; // change Sunday from 0 to 7
    iWeekday2 = (iWeekday2 == 0) ? 7 : iWeekday2;
    if ((iWeekday1 > 5) && (iWeekday2 > 5)) iAdjust = 1; // adjustment if both days on weekend
    iWeekday1 = (iWeekday1 > 5) ? 5 : iWeekday1; // only count weekdays
    iWeekday2 = (iWeekday2 > 5) ? 5 : iWeekday2;

    // calculate differnece in weeks (1000mS * 60sec * 60min * 24hrs * 7 days = 604800000)
    iWeeks = Math.floor((dDate2.getTime() - dDate1.getTime()) / 604800000)
    //console.log("iWeeks:" + iWeeks);
    if (iWeekday1 <= iWeekday2) {
      iDateDiff = (iWeeks * 5) + (iWeekday2 - iWeekday1)
    } else {
      iDateDiff = ((iWeeks + 1) * 5) - (iWeekday1 - iWeekday2)
    }

    iDateDiff -= iAdjust; // take into account both days on weekend

    for(i = 0; i < holidays.length; i++) {
      if(holidays[i] >= dDate1 && holidays[i] <= dDate2 && holidays[i].getDay() != 0 && holidays[i].getDay() != 6) {
        iDateDiff--;
      }
    }

    return (iDateDiff + 1); // add 1 because dates are inclusive
    //return (iDateDiff); // add 1 because dates are inclusive
  }

//var holidays = [ new Date(2017, 5, 2), new Date(2017, 5, 3), new Date(2017, 5, 4), new Date(2017, 5, 5) ];
var holidays = [];






function convertSPDate(d) {
/*
*  A function to convert a standard SharePoint
*  date/time field (YYYY-MM-DD HH:MM:SS) to a
*  javascript Date() object
*
*  Author: Ben Tedder (www.bentedder.com)
*/
  // split apart the date and time
  try {
  var xDate = d.split("T")[0];
  var xTime = d.split("T")[1];

  // split apart the hour, minute, & second
  var xTimeParts = xTime.split(":");
  var xHour = xTimeParts[0];
  var xMin = xTimeParts[1];
  var xSec = xTimeParts[2];

  // split apart the year, month, & day
  var xDateParts = xDate.split("-");
  var xYear = xDateParts[0];
  var xMonth = xDateParts[1];
  var xDay = xDateParts[2];

  var dDate = new Date(xYear, xMonth, xDay, xHour, xMin, xSec);
  return dDate;
} catch (ex) {
  return null;
}
}

function convertSPDateOnly(d) {
/*
*  A function to convert a standard SharePoint
*  date/time field (YYYY-MM-DD HH:MM:SS) to a
*  javascript Date() object
*
*  Author: Ben Tedder (www.bentedder.com)
*/
  // split apart the date and time
  try {
  var xDate = d.split("T")[0];
  var xTime = d.split("T")[1];

  // split apart the hour, minute, & second
  var xTimeParts = xTime.split(":");
  var xHour = xTimeParts[0];
  var xMin = xTimeParts[1];
  var xSec = xTimeParts[2];

  // split apart the year, month, & day
  var xDateParts = xDate.split("-");
  var xYear = xDateParts[0];
  var xMonth = xDateParts[1];
  var xDay = xDateParts[2];

  //var dDate = new Date(xYear, xMonth, xDay, xHour, xMin, xSec);
  //var dDate =
  return xDate;
} catch (ex) {
  return null;
}
}






function xmlToJson(xml) {

// Create the return object
var obj = {};

if (xml.nodeType == 1) { // element
  // do attributes
  if (xml.attributes.length > 0) {
  obj["@attributes"] = {};
    for (var j = 0; j < xml.attributes.length; j++) {
      var attribute = xml.attributes.item(j);
      obj["@attributes"][attribute.nodeName] = attribute.nodeValue;
    }
  }
} else if (xml.nodeType == 3) { // text
  obj = xml.nodeValue;
}

// do children
if (xml.hasChildNodes()) {
  for(var i = 0; i < xml.childNodes.length; i++) {
    var item = xml.childNodes.item(i);
    var nodeName = item.nodeName;
    if (typeof(obj[nodeName]) == "undefined") {
      obj[nodeName] = xmlToJson(item);
    } else {
      if (typeof(obj[nodeName].push) == "undefined") {
        var old = obj[nodeName];
        obj[nodeName] = [];
        obj[nodeName].push(old);
      }
      obj[nodeName].push(xmlToJson(item));
    }
  }
}
return obj;
};





function OpenDialog(strPageURL)

{

  var dialogOptions = SP.UI.$create_DialogOptions();

  dialogOptions.url = strPageURL;// URL of the Page

  dialogOptions.title = 'Glossary Definition'

  dialogOptions.allowMaximize= true

  dialogOptions.width = 650; // Width of the Dialog

  dialogOptions.height = 500; // Height of the Dialog

  dialogOptions.dialogReturnValueCallback = Function.createDelegate( null, CloseCallback); // Function to capture dialog closed event

  SP.UI.ModalDialog.showModalDialog(dialogOptions); // Open the Dialog

  return false;

}




// Dialog close event capture function

function CloseCallback(strReturnValue, target)

{

  if (strReturnValue === SP.UI.DialogResult.OK) // Perform action on Ok.

    {

   alert("User clicked Ok!");

    }

  if (strReturnValue === SP.UI.DialogResult.cancel) // Perform action on Cancel.

   {

 //  alert( "User clicked Cancel!");

   }

}

function addResource(input) {
  //console.log($(input).val());
   newName = $(input).val();


}




function alterResourceStatus(checkbox) {
//  console.log(checkbox);
//  console.log($(checkbox).is(':checked'));
  var checkedStatus = $(checkbox).is(':checked');
  var keyName = $(checkbox).attr('id');
  var resName = $(checkbox).attr('resource');
  if(checkedStatus == true)
  {
  d3.select("[id='assignedto-"+resName+"']").classed("Remove", true);

} else {
//  $("[id='assignedto-"+resName+"']").removeClass("Remove");
  d3.select("[id='assignedto-"+resName+"']").classed("Remove",false);
}

wrapper = document.querySelector('.chart');
infowrapper = document.querySelector('#info');

wrapperDetails = wrapper.getBoundingClientRect();
infoDetails = infowrapper.getBoundingClientRect();

bBoxHeight = wrapperDetails.height;

console.log('bboxheight:' + bBoxHeight);

$(".axisWeekFloating3.tick > line").attr("y2",-(wrapperDetails.height));

  //d3.select("[]")
  //  console.log($("[id='assignedto-"+resName+"']").html());
//  console.log(d3.select("[id='assignedto-"+resName+"']").html());
//  return d3.select("[id='assignedto-"+resName+"']").html();
}



 window.MATRIXDATA = [];


Sys.Application.add_load(initSomething);
function initSomething() {
 console.log("page reloaded");



//TRAINING DATA
// NB Also find and change const trainingProjects = false if you want to disable training
 d3.xml(XMLFileName, function(error, data) {
// REGULAR data
 //d3.xml("/Data/Project Ready Matrix Data.xml", function(error, data) {
 //d3.json("deliverables.json", function(error, json) {
   if (error) return console.warn(error);

       const parser = d3.isoParse;

         var json = xmlToJson(data);
         itemData = json.Items.Item;
         itemDataCopy = itemData;
         itemDataCopy2 = itemData;

    //     console.log(itemDataCopy);

         itemData = $(itemData).filter(function(i, n) {return n.FinishDateExpression != null ; });
         itemData = $(itemData).filter(function(i, n) {return n.FinishDateExpression["#text"] != null ; });
         itemData = $(itemData).filter(function(i, n) {return n.StartDateExpression != null ; });
         itemData = $(itemData).filter(function(i, n) {return n.StartDateExpression["#text"] != null ; });

        itemData = $(itemData).filter(function(i, n) {return n.WebHref["#text"].toUpperCase().indexOf("/TEMPLATES/") < 0 ; });
         itemData = $(itemData).filter(function(i, n) {return n.TSCProjectReadyMatrix["#text"] == "300-Construction" ; });
         itemData = $(itemData).filter(function(i, n) {return parseFloat(n.PercentComplete["#text"]) < 1 ; });


if (trainingProjects == true) {
           itemData = $(itemData).filter(function(i, n) {return n.WebHref["#text"].toUpperCase().indexOf("TRAINING") >= 0 ; });
} else {
           itemData = $(itemData).filter(function(i, n) {return n.WebHref["#text"].toUpperCase().indexOf("TRAINING") < 0 ; });
}



              // RETURN ONLY 1 YEAR IN ADVANCE
              itemData=$(itemData).filter(function(i, n) {

                var startDate = convertSPDateOnly(n.StartDateExpression["#text"]);
              //  var dateArr = n.StartDateExpression["#text"].split("-");

              //  var year = dateArr[0];
                var d = new Date();
                var yearFromNow = new Date(d.getFullYear()+1, d.getMonth(), d.getDate());
                //var thisYear = d.getFullYear();
              //  console.log(thisYear);
              //  if (parseInt(year) > 2020) {
                  return new Date(startDate) < yearFromNow;
              //  }
              });


            var designMatrixtext = "040-Project Design";
                var approvalMatrixtext = "060-Approvals";

          itemData = $.map(itemData, function (item, i){

              var startDate = convertSPDateOnly(item.StartDateExpression["#text"]);
              var UniqueReference = item.UniqueReference["#text"];

      //// NEW STUFF RE DESIGN STATUS

              var designStatus = -1;

          //    try{
                 $(itemDataCopy).filter(function(k, desItem) {
                  // console.log(desItem.TSCProjectReadyMatrix["#text"]);
                   try {
                     thisItemMatrixText = desItem.TSCProjectReadyMatrix["#text"];
                     thisItemReference = desItem.UniqueReference["#text"];
            //     console.log("desItem PRM:" + desItem.ProjectReadyMatrix["#text"] + "desItemRef:" + desItem.Reference["#text"] + "thisItemRef:" + n.Reference["#text"]);
                    if ( designMatrixtext.localeCompare(thisItemMatrixText) == 0 && UniqueReference.localeCompare(thisItemReference) == 0) {
                      designStatus = desItem.PercentComplete["#text"];
                      return;
                      }
                  } catch(ex) {};
              });


              item["DesignStatus"] = designStatus;

  //////////////


  //// NEW STUFF RE approvalstatus

          var approvalStatus = -1;

      //    try{
             $(itemDataCopy).filter(function(j, appItem) {
              // console.log(desItem.TSCProjectReadyMatrix["#text"]);
               try {
                 thisItemMatrixText = appItem.TSCProjectReadyMatrix["#text"];
                 thisItemReference = appItem.UniqueReference["#text"];
        //     console.log("desItem PRM:" + desItem.ProjectReadyMatrix["#text"] + "desItemRef:" + desItem.Reference["#text"] + "thisItemRef:" + n.Reference["#text"]);
                if ( approvalMatrixtext.localeCompare(thisItemMatrixText) == 0 && UniqueReference.localeCompare(thisItemReference) == 0) {
                  approvalStatus = appItem.PercentComplete["#text"];
                  return;
                  }
              } catch(ex) {};
          });


          item["ApprovalStatus"] = approvalStatus;

//////////////

              if(item.AssignedTo.hasOwnProperty("#text")) {
                var splitAssTo = item.AssignedTo["#text"].split(";#");

                item["AssignedToName"] = splitAssTo[1];
                item["AssignedToId"] = splitAssTo[0];
                item["AssignedToAndStartDate"] = splitAssTo[1] + startDate;
                item["UID"] = startDate + "_" +item.UniqueReference["#text"] + "_" + item.ID["#text"];
              //  item["AssignedToName"] = item.AssignedTo["#text"];
              //  return item;
              } else {
                item.AssignedToName = "ZZ Not assigned";
                item.AssignedtoId = "0";
                item.AssignedToAndStartDate = "ZZ Not assigned"+startDate;
                item["UID"] = startDate + "_" +item.UniqueReference["#text"] + "_" + item.ID["#text"];
            //    return item;
              }

              if(item.Owner.hasOwnProperty("#text")) {
                var splitOwner = item.Owner["#text"].split(";#");

                item["OwnerName"] = splitOwner[1];
                item["OwnerId"] = splitOwner[0];
              //  item["AssignedToAndStartDate"] = splitAssTo[1] + startDate;
              //  item["UID"] = startDate + "_" +item.UniqueReference["#text"] + "_" + item.ID["#text"];
              //  item["AssignedToName"] = item.AssignedTo["#text"];
              //  return item;
              } else {
                item.OwnerName = "No owner";
                item.OwnerId = "0";
              //  item.AssignedToAndStartDate = "ZZ Not assigned"+startDate;
              //  item["UID"] = startDate + "_" +item.UniqueReference["#text"] + "_" + item.ID["#text"];
              //  return item;
              }
              return item;


          });



         itemData.sort(function (x, y) {
            //return x.AssignedTo["#text"] - y.AssignedTo["#text"];
            return x.AssignedToAndStartDate - y.AssignedToAndStartDate;

         });

/*         itemData.sort(function (a, b) {

           var assignedTest = a.AssignedTo["#text"] - b.AssignedTo["#text"];
           var dateTest = parser(convertSPDateOnly(a.StartDateExpression["#text"])) - parser(convertSPDateOnly(b.StartDateExpression["#text"]));
           return assignedTest + dateTest;
       });*/




 window.MATRIXDATA = itemData;


   runAfterEverythingElse();


          //numberofTasks = itemData.length;
 });


//console.log(MATRIXDATA);
//runAfterEverythingElse();
 //_spBodyOnLoadFunctionNames.push("runAfterEverythingElse");
   //runAfterEverythingElse();
   //alert("The ajax call was completed");
}








</script>
